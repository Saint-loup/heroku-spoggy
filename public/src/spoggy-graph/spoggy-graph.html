<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="../../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../bower_components/paper-dialog-scrollable/paper-dialog-scrollable.html">
<link rel="import" href="../../bower_components/paper-dialog-behavior/paper-dialog-behavior.html">
<link rel="import" href="../../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../../bower_components/paper-checkbox/paper-checkbox.html">

<link rel="import" href="../../bower_components/iron-collapse-button/iron-collapse-button.html">


<!--
revoir color picker -->
<link rel="import" href="../../bower_components/color-picker/color-picker.html">
<link rel="import" href="../../bower_components/color-picker/color-element.html">
<link rel="import" href="../../bower_components/paper-swatch-picker/paper-swatch-picker.html">
<link rel="import" href="../../bower_components/neon-animation/web-animations.html">

<script src="../../bower_components/vis/dist/vis.min.js"></script>

<link rel="import" href="../spoggy-data/data-behavior.html">

<link rel="import" href="styles/vis-styles.html">
<link rel="import" href="styles/graphe-styles.html">

<dom-module id="spoggy-graph">
  <template>
    <style is="custom-style"  include="graphe-styles"></style>
    <style is="custom-style"  include="vis-styles"></style>
    <paper-dialog id="nodePopUp" backdrop transition="core-transition-bottom">
      <div horizontal start-justified start layout >
        <core-icon icon="thumb-up" style="height: 150px; width:150px;color: #0D578B;"></core-icon>
        <div style="padding-left:20px" vertical start-justified start layout wrap>

          <!--<h1 style="margin: 0;color: #0D578B;">SUCCESS!</h1>-->
          <h2 id="nodeOperation" style="margin: 0;color: #0D578B;">Ajouter ou modifier un noeud</h2>
          <p>
            <paper-input id="nodeLabel" label="Nom du noeud"></paper-input>
            <!-- checkbox style : https://codepen.io/sevilayha/pen/jCmgE -->
          </p>


          <iron-collapse-button>
            <h3 slot="collapse-trigger" style="margin: 0;color: #0D578B;">Forme</h3>
            <div slot="collapse-content">
              <fieldset>
                <legend>Forme</legend>
                <iron-selector id="shapeSelector" attr-for-selected="name" selected="{{selectedShape}}" selected-attribute="checked">
                  <div>Label interne</div>
                  <paper-checkbox name="ellipse">Ellipse</paper-checkbox>
                  <paper-checkbox name="circle">Cercle</paper-checkbox>
                  <paper-checkbox name="database">Database</paper-checkbox>
                  <paper-checkbox name="box">Box</paper-checkbox>
                  <paper-checkbox name="text">Texte</paper-checkbox>
                  <hr>
                  <div>Label externe</div>
                  <paper-checkbox name="diamond">Diamant</paper-checkbox>
                  <paper-checkbox name="star">Etoile</paper-checkbox>
                  <paper-checkbox name="triangle">Triangle</paper-checkbox>
                  <paper-checkbox name="triangleDown">Triangle inverse</paper-checkbox>
                  <paper-checkbox name="square">Carré</paper-checkbox>
                  <!--          <paper-checkbox name="image" disabled>Image</paper-checkbox>
                  <paper-checkbox name="circularImage" disabled>Image Cercle</paper-checkbox>
                  <paper-checkbox name="icon" disabled>Icone</paper-checkbox>-->
                </iron-selector>
              </fieldset>
            </div>
          </iron-collapse-button>

          <iron-collapse-button>
            <h3 slot="collapse-trigger" style="margin: 0;color: #0D578B;">Couleur</h3>
            <div slot="collapse-content">
              <fieldset>
                <legend>Couleur</legend>
                <!--<paper-swatch-picker></paper-swatch-picker>-->
                <color-picker  id="colorpicker" native value="{{colorValue}}"  position="right"></color-picker>
                <div class="horizontal-section-container result">
                  <!--  <div><code>hex</code>: <b>[[colorValue]]</b></div>
                  css-value="{{cssValue}}" alpha="{{alpha}}"
                  <div><code>alpha</code>: <b>[[alpha]]</b></div>
                  <div><code>css-value</code>: <b>[[cssValue]]</b></div>-->
                </div>
              </fieldset>
            </div>
          </iron-collapse-button>


          <iron-collapse-button>
            <h3 slot="collapse-trigger" style="margin: 0;color: #0D578B;">Type</h3>
            <div slot="collapse-content">
              (developpements en cours)
              <fieldset>
                <legend>Type</legend>
                <iron-selector id="typeSelector" attr-for-selected="name" selected="{{selectedType}}" selected-attribute="checked">
                  <paper-checkbox name="node">Node</paper-checkbox>
                  <paper-checkbox name="url">Url</paper-checkbox>
                  <paper-checkbox name="graph">Graphe</paper-checkbox>
                  <paper-checkbox name="source">Source</paper-checkbox>
                </iron-selector>
              </fieldset>
            </div>
          </iron-collapse-button>

          <div style="padding-top:10px" horizontal end-justified layout self-stretch>
            <paper-button id="nodeSaveButton" on-tap="saveNodeData" raised>ok</paper-button>
            <paper-button id="nodeCancelButton"  dialog-dismiss raised>Annuler</paper-button>
          </div>
        </div>
      </div>
    </paper-dialog>


    <paper-dialog id="edgePopUp" backdrop transition="core-transition-bottom">
      <div horizontal start-justified start layout >
        <core-icon icon="thumb-up" style="height: 150px; width:150px;color: #0D578B;"></core-icon>
        <div style="padding-left:20px" vertical start-justified start layout wrap>
          <h2 id="edgeOperation" style="margin: 0;color: #0D578B;">Ajouter ou modifier un lien</h2>
          <p >  <paper-input id="edgeLabel" label="Nom du lien"></paper-input></p>
          <div style="padding-top:10px" horizontal end-justified layout self-stretch>
            <paper-button id="edgeSaveButton"  on-tap="saveEdgeData" raised>ok</paper-button>
            <paper-button id="edgeCancelButton" dialog-dismiss raised>Annuler</paper-button>
          </div>
        </div>
      </div>
    </paper-dialog>

    <paper-dialog id="importPopUp" backdrop transition="core-transition-bottom">
      <div horizontal start-justified start layout >
        <core-icon icon="thumb-up" style="height: 150px; width:150px;color: #0D578B;"></core-icon>
        <div style="padding-left:20px" vertical start-justified start layout wrap>
          <h2 id="edgeOperation" style="margin: 0;color: #0D578B;">Import JSON</h2>
          <p >
            <fieldset>
              <legend>Paramètres</legend>
              <paper-checkbox id="remplaceNetwork">Remplacer Network</paper-checkbox>
              <paper-checkbox id="partageImport" disabled >Partager Import</paper-checkbox>
            </fieldset>
          </p>
          <p>
            <fieldset>
              <legend>Fichier</legend>
              <input id="filepicker" type="file" multiple value="Importer"></input>
            </fieldset>
          </p>
          <div style="padding-top:10px" horizontal end-justified layout self-stretch>
            <paper-button id="importCancelButton" on-tap="_closeImportPopUp"  dialog-dismiss raised>Annuler</paper-button>
          </div>
        </div>
      </div>
    </paper-dialog>


    <paper-dialog id="settings" hidden$="{{settinghidden}}">
      <div>  <!--AJOUTER LE CHANGEMENT DE PHYSICS -->
        Gravité   <paper-slider  min="0" max="0.01" value="{{gravityValue}}" step="0.001" on-change="_changeGravity" ></paper-slider>
        Longueur des liens     <paper-slider  min="10" max="800" value="{{springLengthValue}}"  on-change="_changeSpringLength"></paper-slider>
        Force des liens   <paper-slider  min="0" max="0.2" value="{{springConstantValue}}"  step="0.001" on-change="_changeSpringConstant"></paper-slider>
        Distance entre deux noeuds     <paper-slider  min="10" max="800" value="{{nodeDistanceValue}}"  on-change="_changeNodeDistance"></paper-slider>
        Souplesse           <paper-slider  min="0.01" max="2" value="{{dampingValue}}"  step="0.01" on-change="_changeDamping"></paper-slider>
        <paper-button raised  on-tap="_defaultPhysicValues">Defaut</paper-button>
        <br><br>
      </div>
      <div>
        <!--<spog-source></spog-source>-->
      </div>
    </paper-dialog>


    <div id="mynetwork"></div>
  </template>

  <script>
  /**
  * `spoggy-graph`
  *
  *
  * @customElement
  * @polymer
  * @demo demo/index.html
  */
  class SpoggyGraph extends DataBehaviorMixin(Polymer.Element) {
    static get is() { return 'spoggy-graph'; }
    static get properties() {
      return {
        prop1: {
          type: String,
          value: 'spoggy-graph'
        },
        network : {
          type: Object,
          notify: true
        },
        addToGraph: {
          observer: '_addToGraphArrivedGRAPH',
          notify: true
        }
      };
    }
    constructor(){
      super();
      /*  console.log(this.methodInBehavior());
      console.log(this.test);
      console.log(this.prop1);*/
    }
    log(){
      console.log(this.methodInBehavior());
      console.log(this.test);
      console.log(this.prop1);
    }
    connectedCallback(){
      super.connectedCallback();
      this.network = this.networkDivInitialize(this.$.mynetwork, this);
    }

    //////////////////////////////////////////////////////////////////
    networkDivInitialize(container, graphe){
      // create an array with nodes
      var nodes = new vis.DataSet([
        {id: "node1", label: 'Spoggy', color: 'rgb(195,238,0)'},
        {id: "node2", label: 'WebApp', color: 'rgba(97,238,195,0.5)'},
        {id: "node3", label: 'David'},
        {id: "node4", label: 'Bob'},
        {id: "node5", label: 'Graph', color: 'rgba(195,238,97,0.5)', cid:2},
        {id: "node6", label: 'Spoggy est une application multiutilisateurs\n permettant la création de graphes de connaissance.\n Cliquez sur le bouton Edit\n pour ajouter / modifier un noeud ou un lien.', color: 'rgba(238,97,195,0.5)', shape: 'box', cid:1},
        {id: "node7", label: 'Description', color: 'rgba(238,97,195,0.5)', cid:1},
        {id: "node8", label: 'Un graphe est un ensemble de noeuds\n et de liens entre ces noeuds.', color: 'rgba(238,97,195,0.5)', shape: 'box', cid:1},
        {id: "node9", label: 'graph0', color: 'rgba(238,97,195,0.5)', type: 'graph', name: 'graph0'},
        {id: "node10", label: 'graph1', color: 'rgba(238,97,195,0.5)', type: 'graph', name: 'graph1'},
        {id: "node11", label: 'graph2', color: 'rgba(238,97,195,0.5)', type: 'graph', name: 'graph2'},
      ]);
      // create an array with edges
      var edges = new vis.DataSet([
        {from: "node1", to: "node2", label: "type", array:"to"},
        {from: "node1", to: "node3", label: "developpeur", array:"to"},
        {from: "node3", to: "node4", label: "connait", array:"to"},
        {from: "node1", to: "node5", label: "hasPart", array:"to"},
        {from: "node1", to: "node6", label: "description", array:"to"},
        {from: "node6", to: "node7", label: "type", array:"to"},
        {from: "node5", to: "node8", label: "description", array:"to"},
        {from: "node8", to: "node7", label: "type", array:"to"},
        {from: "node9", to: "node5", label: "type", array:"to"},
        {from: "node10", to: "node5", label: "type", array:"to"},
        {from: "node11", to: "node5", label: "type", array:"to"},
        {from: "node1", to: "node9", label: "first", array:"to"},

      ]);
      var data = {
        nodes: nodes,
        edges: edges
      };
      var options = {
        edges:{
          arrows: {
            to:     {enabled: true, scaleFactor:1, type:'arrow'},
            middle: {enabled: false, scaleFactor:1, type:'arrow'},
            from:   {enabled: false, scaleFactor:1, type:'arrow'}
          }},
          interaction:{
            navigationButtons: true,
            //  keyboard: true  //incompatible avec rappel de commande en cours d'implémentation
          },
          manipulation: {
            addNode: function (data, callback) {
              // filling in the popup DOM elements
              data.label = "";
              //  console.log(this);
              graphe.editNode(data, callback);
            },
            editNode: function (data, callback) {
              // filling in the popup DOM elements
              //document.getElementById('nodeOperation').innerHTML = "Edit Node";
              graphe.$.nodeOperation.innerHTML = "Edit Node";
              graphe.editNode(data, callback);
            },
            deleteNode: function (data, callback) {
              // filling in the popup DOM elements
              graphe.deleteNode(data, callback);
            },
            addEdge: function (data, callback) {
              if (data.from == data.to) {
                var r = confirm("Êtes-vous certain de vouloir connecter le noeud à lui-même?");
                if (r != true) {
                  callback(null);
                  return;
                }
              }
              //document.getElementById('edgeOperation').innerHTML = "Add Edge";
              graphe.$.edgeOperation.innerHTML = "Add Edge";
              graphe.editEdgeWithoutDrag(data, callback);
            },
            editEdge: {
              editWithoutDrag: function(data, callback) {
                //document.getElementById('edgeOperation').innerHTML = "Edit Edge";
                graphe.$.edgeOperation.innerHTML = "Edit Edge";
                graphe.editEdgeWithoutDrag(data,callback);
              }
            },
            deleteEdge: function(data,callback){
              graphe.deleteEdge(data,callback);
            }
          },
          physics:{
            enabled: true,
            barnesHut: {
              gravitationalConstant: -1,
              centralGravity: 0.3,
              springLength: 95,
              springConstant: 0.04,
              damping: 0.09,
              avoidOverlap: 1
            },
            forceAtlas2Based: {
              gravitationalConstant: -50,
              centralGravity: 0.01,
              springConstant: 0.08,
              springLength: 100,
              damping: 0.4,
              avoidOverlap: 0
            },
            repulsion: {
              centralGravity: 0.001, //0.001 ? A quoi sert cette valeur ?
              springLength: 220, //220 (//200 //300)
              springConstant: 0.01, //0.01
              nodeDistance: 150, //100 //350
              damping: 0.08
            },
            hierarchicalRepulsion: {
              centralGravity: 0.0,
              springLength: 100,
              springConstant: 0.01,
              nodeDistance: 120,
              damping: 0.09
            },
            maxVelocity: 500, //50
            minVelocity: 1, //0.1
            solver: 'repulsion',
            stabilization: {
              enabled: true,
              iterations: 1000,
              updateInterval: 100,
              onlyDynamicEdges: false,
              fit: true
            },
            timestep: 0.5,
            adaptiveTimestep: true
          }
        };
        return new vis.Network(container, data, options);
      }
      editNode (data, callback) {
        console.log(data);
        this.$.nodeLabel.value= data.label || "";
        this.selectedShape = data.shape || "ellipse";
        this.selectedType = data.type || "node";
        this.colorValue = data.color || "rgb(173,208,255)";

        this.$.nodeSaveButton.onclick = this.saveNodeData.bind(this, data, callback);
        this.$.nodeCancelButton.onclick = this.clearNodePopUp.bind(this);
        this.$.nodePopUp.style.display = 'block';
        this.$.nodeLabel.focus();
      }
      clearNodePopUp () {
        this.$.nodeSaveButton.onclick = null;
        this.$.nodeCancelButton.onclick = null;
        this.$.nodePopUp.style.display = 'none';
      }
      cancelNodeEdit (callback) {
        this.clearNodePopUp(this);
        callback(null);
      }
      saveNodeData (data, callback) {
        /*
        let dataTemp = data;
        let cb = callback;
        console.log(dataTemp);
        console.log(cb);
        console.log(data.type);
        data et callback apparaissent comme des events ?????
        {id: "38e05a49-feb0-4d65-a35f-c7c7d973390e", x: -518.5339336634761, y: -388.3170534287593, label: ""}
        spoggy-graph.html:373 Event {isTrusted: false, detail: {…}, type: "tap", target: paper-button#nodeSaveButton, currentTarget: paper-button#nodeSaveButton, …}
        spoggy-graph.html:374 {x: 138, y: 588, sourceEvent: MouseEvent, preventer: undefined}preventer: undefinedsourceEvent: MouseEvent {isTrusted: true, __polymerGesturesHandled: {…}, screenX: 2058, screenY: 654, clientX: 138, …}x: 138y: 588__proto__: Object
        spoggy-graph.html:378 tap
        */

        data.label = this.$.nodeLabel.value;
        data.shape = this.selectedShape;
        data.color = this.colorValue;

        data.type = this.selectedType;
        if (data.label.length > 40){
          var titleTemp =data.label.match(/.{1,40}/g);
          //  console.log(titleTemp);
          data.label = titleTemp.join("\n");
          //  data.shape = "box";
          //  data.mass = 1/data.label.length
        }
        this.clearNodePopUp(this);
        callback(data);
        var node = this.network.body.data.nodes.get(data.id);
        console.log(node);
        var action = {};
        action.type = "newNode";
        action.data = node;
        console.log
        this.addAction(action);
        if( data.type == "graph"){
          console.log("nodeID");
          console.log(node.id);
          var graphNode = this.network.body.data.nodes.get({
            filter: function(node){
              console.log(node);
              return (node.label == "Graph" );
            }
          });
          console.log(graphNode);
          if (graphNode.length == 0){
            console.log("creation du noeud graph");
            var nodeGraph = {};
            nodeGraph.label = "Graph";
            nodeGraph.shape = "star";
            nodeGraph.type = "node";
            nodeGraph.color= "rgb(255,0,0)";
            this.network.body.data.nodes.add(nodeGraph);
          }else{
            console.log("récupération du noeud graph");
          }
          graphNode = this.network.body.data.nodes.get({
            filter: function(node){
              console.log(node);
              return (node.label == "Graph" );
            }
          });
          var actionNodeGraph = {};
          actionNodeGraph.type = "newNode";
          actionNodeGraph.data = graphNode[0];
          this.addAction(actionNodeGraph);
          console.log(graphNode);
          console.log(node.id);
          var edgeGraph = {};
          edgeGraph.from = node.id;
          edgeGraph.to = graphNode[0].id;
          edgeGraph.label = "type";
          var graphEdge = this.network.body.data.edges.get({
            filter: function(edge){
              console.log(edge);
              return (edge.from == edgeGraph.from && edge.to == edgeGraph.to && edge.label == edgeGraph.label);
            }
          });
          console.log(graphEdge);
          if(graphEdge.length == 0){
            this.network.body.data.edges.add(edgeGraph);
          }
          graphEdge = this.network.body.data.edges.get({
            filter: function(edge){
              console.log(edge);
              return (edge.from == edgeGraph.from && edge.to == edgeGraph.to && edge.label == edgeGraph.label);
            }
          });
          console.log("EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEee");
          console.log(graphEdge);
          var actionedgeGraph = {};
          actionedgeGraph.type = "newEdge";
          actionedgeGraph.data = graphEdge;
          this.addAction(actionedgeGraph);
        }
        /*
        if( data.type == "graph"){
        var graphNode = this.network.body.data.nodes.get({
        filter: function(node){
        console.log(node);
        return (node.label == "Graph" );
      }
    });
    console.log(graphNode);
    var n ;
    if(graphNode.length==0){
    console.log("creation");
    // creation du noeud Graph
    var nodeGraph = {};
    nodeGraph.label = "Graph";
    nodeGraph.shape = "star";
    n= this.network.body.data.nodes.add(nodeGraph)[0];
  }else{
  console.log("exist");
  n = graphNode[0].id;
}
console.log(n);
var actionTo = {};
actionTo.type = "newNode";
actionTo.data = this.network.body.data.nodes.get(n);
console.log(actionTo);
this.addAction(actionTo);
var edgeGraph = {};
edgeGraph.label = "type";
edgeGraph.from = data.id;
edgeGraph.to = n;
this.addEdgeIfNotExist(this.network, edgeGraph);
var edge;
var existEdge = this.network.body.data.edges.get({
filter: function(edge){
return (edge.from == edgeGraph.from && edge.to == edgeGraph.to && edge.label == edgeGraph.label);
}
});
console.log(existEdge);
if(existEdge.length == 0){
edge = this.network.body.data.edges.update(edgeGraph);
}else{
edge = existEdge[0];
}
console.log(edge);
var actionGraph = {};
actionGraph.type = "newEdge";
//var e= this.network.body.data.edges.update(edgeGraph);
var e = this.network.body.data.edges.get(edge[0]);
console.log(e);
actionGraph.data = e;
console.log(actionGraph);
this.addAction(actionGraph);
*/
//}
/*this.nodes = [];
this.nodes = this.network.body.data.nodes;*/
}

editEdgeWithoutDrag (data, callback) {
  this.$.edgeLabel.value = data.label || "";
  this.$.edgeSaveButton.onclick = this.saveEdgeData.bind(this, data, callback);
  this.$.edgeLabel.onchange = this.saveEdgeData.bind(this, data, callback);
  this.$.edgeCancelButton.onclick = this.cancelEdgeEdit.bind(this,callback);
  this.$.edgePopUp.style.display = 'block';
  this.$.edgeLabel.focus();
}
clearEdgePopUp () {
  this.$.edgeSaveButton.onclick = null;
  this.$.edgeCancelButton.onclick = null;
  this.$.edgePopUp.style.display = 'none';
}
cancelEdgeEdit (callback) {
  this.clearEdgePopUp();
  callback(null);
}
saveEdgeData (data, callback) {
  if (typeof data.to === 'object')
  data.to = data.to.id
  if (typeof data.from === 'object')
  data.from = data.from.id
  data.label = this.$.edgeLabel.value;
  this.clearEdgePopUp();
  callback(data);
  var edge = this.network.body.data.edges.get({
    filter: function(edge) {
      return (edge.from == data.from && edge.to == data.to && edge.label == data.label);
    }
  });
  var action = {};
  action.type = "newEdge";
  action.data = edge;
  this.addAction(action);
}
deleteNode (data, callback){
  var action = {};
  action.type = "deleteNode";
  action.data = data;
  this.addAction(action);
  callback(data);
}
deleteEdge (data, callback){
  var action = {};
  action.type = "deleteEdge";
  action.data = data;
  this.addAction(action);
  callback(data);
}

addEdgeIfNotExist (network, data){
  var existEdge = false;
  console.log(data);
  try {
    existEdge = this.network.body.data.edges.get({
      filter: function(edge){
        return (edge.id == data[0].id);
      }
    });
    if (existEdge.length == 0){
      this.network.body.data.edges.add(data[0]);
    }else{
      this.network.body.data.edges.update({id: data[0].id, label: data[0].label});
    }
  }
  catch (err) {
    console.log(err);
  }
}
addNodeIfNotExist(network, data){
  var existNode = false;
  console.log(data);
  try{
    existNode = this.network.body.data.nodes.get({
      filter: function(node){
        return (node.id == data.id );
      }
    });
    console.log(existNode);
    if (existNode.length == 0){
      console.log("n'existe pas")
      this.network.body.data.nodes.add(data);
    }else{
      console.log("existe")
      delete data.x;
      delete data.y
      this.network.body.data.nodes.update(data);
    }
  }
  catch (err){
    console.log(err);
  }
}
deleteFromServer (data){
  //Pour suppression, on recupere le noeud et ses liens envoyés par le serveur
  this.network.body.data.nodes.remove(data.nodes);
  this.network.body.data.edges.remove(data.edges);
}
_changeGravity(e){
  this.network.physics.options.repulsion.centralGravity = this.gravityValue;
}
_changeSpringLength(){
  this.network.physics.options.repulsion.springLength = this.springLengthValue;
}
_changeSpringConstant(){
  this.network.physics.options.repulsion.springConstant = this.springConstantValue;
}
_changeNodeDistance(){
  this.network.physics.options.repulsion.nodeDistance = this.nodeDistanceValue;
}
_changeDamping(){
  this.network.physics.options.repulsion.damping = this.dampingValue;
}
_defaultPhysicValues(){
  /*valeurs par Defaut de network.physics.repulsion
  centralGravity: 0.001,
  springLength: 220, //200 //300
  springConstant: 0.005,
  nodeDistance: 180, //100 //350
  damping: 0.08*/
  this.gravityValue = 0.001;
  this.network.physics.options.repulsion.centralGravity = this.gravityValue;
  this.springLengthValue = 200;
  this.network.physics.options.repulsion.springLength = this.springLengthValue;
  this.springConstantValue = 0.01;
  this.network.physics.options.repulsion.springConstant = this.springConstantValue;
  this.nodeDistanceValue = 150;
  this.network.physics.options.repulsion.nodeDistance = this.nodeDistanceValue;
  this.dampingValue = 0.08;
  this.network.physics.options.repulsion.damping = this.dampingValue;
}
_inferedChanged(newInfered,oldinfered){
  console.log("INFERED");
  console.log(newInfered);
  this.populateFromInfered(newInfered, this.network)
}
_toggleSettings(){
  console.log(this.$.settings.hidden);
  //this.$.settings.hidden= !this.$.settings.hidden;
  this.settinghidden = !this.settinghidden;
}
_toggleEye(){
  console.log(this.$.eye.hidden);
  //this.$.eye.hidden= !this.$.eye.hidden;
  this.eyehidden = !this.eyehidden;
}
// CLUSTERS
_toggleDesc() {
  //  network.setData(data);
  var clusterOptionsByData = {
    joinCondition:function(childOptions) {
      return childOptions.cid == 1;
    },
    processProperties: function (clusterOptions, childNodes) {
      //clusterIndex = clusterIndex + 1;
      var clusterIndex = 1
      var childrenCount = 0;
      for (var i = 0; i < childNodes.length; i++) {
        childrenCount += childNodes[i].childrenCount || 1;
      }
      clusterOptions.childrenCount = childrenCount;
      clusterOptions.label = "Description\n# " + childrenCount + "";
      // clusterOptions.font = {size: childrenCount*5+30}
      clusterOptions.id = 'cluster:' + clusterIndex;
      clusterOptions.mass = 1/childrenCount;
      // clusters.push({id:'cluster:' + clusterIndex, scale:scale});
      return clusterOptions;
    },
    clusterNodeProperties: {id:'cidCluster',  color: 'rgba(97,238,195,0.5)', borderWidth:3, shape:'box'}
  };
  this.network.cluster(clusterOptionsByData);
}
_closeImportPopUp(){
  this.$.importPopUp.style.display = 'none';
}
_toogle() {
  console.log("clic");
  this.$.nodePopUp.toggle();
}
saveTextAsFile(){
  var textToWrite="";
  var fileNameToSaveAs="";
  var textFileAsBlob="";
  var extension="ttl";
  var nomFichier="";
  var data = this.$.inputTextToSave.value;
  console.log(data);
  if((typeof data != "undefined")&& (data.length>0)){
    textToWrite=data;
  }else{
    textToWrite = this.$.inputTextToSave.value;    //textToWrite = document.getElementById("inputTextToSave").value;
  }
  if ((typeof nomFichier != "undefined") && (nomFichier.length>0)){
    fileNameToSaveAs = nomFichier+"."+extension;
  }else{
    fileNameToSaveAs = this.$.inputFileNameToSaveAs.value+"."+extension; // fileNameToSaveAs = document.getElementById("inputFileNameToSaveAs").value+"."+extension;
  }
  if ((typeof extension != "undefined") && (extension.length>0)){
    switch(extension){
      case "ttl" :
      textFileAsBlob = new Blob([textToWrite], {
        type:
        'text/turtle'
      }
    );
    break;
    case "rdf" :
    //pas implementé pour l'instant
    textFileAsBlob = new Blob([textToWrite], {
      type:
      'application/rdf+xml'
    }
  );
  break;
  default :
  console.log("non traite  , extension : "+extension);
  break;
}
}
console.log(nomFichier+" : "+extension);
var downloadLink = document.createElement("a");
downloadLink.download = fileNameToSaveAs;
downloadLink.innerHTML = "Download File";
//console.log(window.URL);
//if (window.URL != null)
if(navigator.userAgent.indexOf("Chrome") != -1)
{
  // Chrome allows the link to be clicked
  // without actually adding it to the DOM.
  console.log("CHROME");
  downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
} else
{
  // Firefox requires the link to be added to the DOM
  // before it can be clicked.
  console.log("FF");
  downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
  downloadLink.target="_blank";
  //downloadLink.onclick = destroyClickedElement;
  //downloadLink.onclick = window.URL.revokeObjectURL(downloadLink);
  downloadLink.style.display = "none";
  document.body.appendChild(downloadLink);
  console.log(this.$.popupTtl);
}
console.log(downloadLink);
/*downloadLink.click();*/
/* creation d'un event car download.click() ne fonctionne pas sous Firefox */
var event = document.createEvent("MouseEvents");
event.initMouseEvent(
  "click", true, false, window, 0, 0, 0, 0, 0
  , false, false, false, false, 0, null
);
downloadLink.dispatchEvent(event);
var app = this;
setTimeout(function(){
  document.body.removeChild(downloadLink);
  window.URL.revokeObjectURL(downloadLink);
}, 100);
}
recupParams(){
  var params = (function(a) {
    if (a == "") return {};
    var b = {};
    for (var i = 0; i < a.length; ++i)
    {        var p=a[i].split('=', 2);
    if (p.length == 1)
    b[p[0]] = "";
    else
    b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
  }
  return b;
})(window.location.search.substr(1).split('&'));
return params;
}
}

window.customElements.define(SpoggyGraph.is, SpoggyGraph);
</script>
</dom-module>

<script src="./lib/vis.js"></script>

<script>
var GraphBehaviorMixin = Polymer.dedupingMixin(function(superClass){
  return class GraphBehavior extends superClass {
    constructor() {
      super();
    }
    static get properties() {
      return {
        test: {
          type: String,
          value: 'spoggy-graph behavior'
        },
        network: {
          type: Object,
          notify: true
        }
      };
    }


    importFromParam(params){
      var source = params.source;
      var network = this.network;
      var output = [];
      var xhr = new XMLHttpRequest();
      xhr.open('GET', source, true);
      xhr.responseType = 'blob';
      xhr.onload = function(e) {
        //  console.log(e);
        var reponse = e.target.response;
        //  console.log(reponse);
        var reader = new FileReader(); //https://openclassrooms.com/courses/dynamisez-vos-sites-web-avec-javascript/l-api-file
        reader.addEventListener('load', function () {
          //  console.log(reader.result);
          // ajouter test en fonction du type de fichier, extension
          var nodes = JSON.parse(reader.result).nodes;
          //    console.log(nodes);
          var edges = JSON.parse(reader.result).edges;
          //    console.log(edges);
          network.beforeImport = [];
          network.beforeImport.nodes = network.body.data.nodes.get();
          network.beforeImport.edges = network.body.data.edges.get();
          network.body.data.nodes.update(nodes);
          network.body.data.edges.update(edges);
          try{
            network.body.data.nodes.update(nodes);
            network.body.data.edges.update(edges);
          }
          catch(e){
            console.log(e);
          }
          //  console.log(network);
          //  console.log(partageImport);
        });
        reader.readAsText(reponse);
      };
      xhr.send();
    }

    addToGraph(data){
      console.log(data)
      var app = this;
      if (data.actions.length>0){
        data.actions.forEach(function(action) {
          console.log(action);
          console.log(app.network)
          switch(action.type) {
            case "newNode":
            if(app.network != undefined){
              app.addNodeIfNotExist(app.network, action.data);
            }
            break;
            case "editNode":
            break;
            case "deleteNode":
            app.deleteFromServer(action.data);
            break;
            case "newEdge":
            if(app.network != undefined){
              app.addEdgeIfNotExist(app.network, action.data);
            }
            break;
            case "editEdge":
            break;
            case "deleteEdge":
            app.deleteFromServer(action.data);
            break;
            default:
            console.log("action non reconnue");
            console.log(action);
          }
        });
      }
    }


    populateVis(db) {
      console.log("POPULATE");
      let network = this.network;
      this.network.body.data.nodes.clear();
      this.network.body.data.edges.clear();
      if (db.length > 0) {
        if (db.length % 100 < 5) {
          /*
          Rezoom tous les 100*/
          network.fit();
          network.redraw();
        }
        for (var i = 0; i < 10; i++) {
          var triplet = db.pop();
          if (triplet != undefined) {
            console.log(triplet);
            if ( triplet.predicate == "label") {
              var noeudExist = network.body.data.nodes.get(triplet.subject);
              if (noeudExist == null || noeudExist.length == 0) {
                if (triplet.object.length > 40) {
                  network.body.data.nodes.add({
                    id: triplet.subject,
                    label: triplet.object.match(/.{1,40}/g).join("\n"),
                    //  shape: "box",
                  //  group: 0
                  });
                } else {
                  var node = {
                    id: triplet.subject,
                    label: triplet.object,
                  //  type: triplet.type,
                    //group: 0,
                  };
                  network.body.data.nodes.add(node);
                  if ((node.label.toLowerCase() == "depart") || (node.label.toLowerCase() == "départ")) {
                    //  console.log('trouve depart');
                    //var nodeDep = network.body.data.nodes.get(triplet.subject);
                    //console.log(nodeDep);
                    //nodeDep.color = {background:'pink', border:'purple'};
                    network.body.data.nodes.update({
                      id: triplet.subject,
                      color: {
                        background: 'pink',
                        border: 'purple'
                      }
                    })
                    var nodeDep = network.body.data.nodes.get(triplet.subject);
                    /*nodeDep = network.body.data.nodes.get(triplet.subject);*/
                    network.focus(nodeDep.id);
                    network.fit();
                  }
                  /*  if (node.label.match(/^\d/)) {
                  // Return true if starts with number
                  console.log(node.label);
                  // first number
                  var firstNum = node.label.split(".")[0];
                  network.body.data.nodes.update({
                  id: triplet.subject,
                  group: firstNum
                });
              }*/
            }
          } else {
            //    console.log("exist : ");
            /*            console.log(noeudExist);
            noeudExist.mass++;
            console.log(noeudExist);*/
            //    console.log(triplet);
            network.body.data.nodes.update({
              id: triplet.subject,
              label: triplet.object,
            //  type: triplet.type,
            })
          }
        } /*else if (triplet.type == "shape") {
          console.log(triplet);
          network.body.data.nodes.update({
            id: triplet.subject,
            shape: triplet.object
          })
        }
        else if (triplet.type == "color") {
          console.log(triplet);
          network.body.data.nodes.update({
            id: triplet.subject,
            color: triplet.object
          })
        }     */  else {
          var edgeExist = [];
          edgeExist = network.body.data.edges.get(triplet.subject);
          if (edgeExist == null || edgeExist.length == 0) {
            var edge = {
              id: "",
              from: "",
              to: "",
              label: "",
              arrows: "to"
            };
            edge.id = triplet.subject;
            edge[triplet.predicate] = triplet.object;
            network.body.data.edges.add(edge);
          } else {
            var edge = edgeExist;
            edge[triplet.predicate] = triplet.object;
            network.body.data.edges.update(edge);
          }
        }
      } else {
        console.log("import terminé")
        //  network.focus(nodeDep);
        clearInterval(this.tickInterval);
        var app = this;
        console.log("revoir app.eyedata = app.network.body.data")
        /*  this.tickInterval = setInterval(function() {
        if (!app.eyehidden){
        console.log("kick");
        //  app.eyedata = [];
        app.eyedata = app.network.body.data;
      }
    }, 5000);*/
  }
}
}
}




deleteFromServer (data){
  console.log("delete ")
  console.log(data)
  //Pour suppression, on recupere le noeud et ses liens envoyés par le serveur
  this.network.body.data.nodes.remove(data.nodes);
  this.network.body.data.edges.remove(data.edges);
}

catchTriplet(message){
  // A REVOIR ET REMPLACER PAR catchTripletsV2()
  //  console.log(message.length);
  //message=message.trim();
  //  var tripletString = message.substring(2).trim().split(" ");
  //  var tripletString = message.trim().split(" ");
  // les noeuds existent-ils ?
  var sujetNode = this.network.body.data.nodes.get({
    filter: function(node){
      //    console.log(node);
      return (node.label == message[0] );
    }
  });
  var objetNode = this.network.body.data.nodes.get({
    filter: function(node){
      //    console.log(node);
      return (node.label == message[2]);
    }
  });
  console.log(sujetNode);
  console.log(objetNode);
  // sinon, on les créé
  if (sujetNode.length == 0){
    this.network.body.data.nodes.add({label: message[0] });
  }
  if (objetNode.length == 0){
    this.network.body.data.nodes.add({ label: message[2] });
  }
  // maintenant ils doivent exister, pas très po=ropre comme méthode , à revoir
  sujetNode = this.network.body.data.nodes.get({
    filter: function(node){
      console.log(node);
      return (node.label == message[0] );
    }
  });
  objetNode = this.network.body.data.nodes.get({
    filter: function(node){
      console.log(node);
      return (node.label == message[2]);
    }
  });
  var actionSujet = {};
  actionSujet.type = "newNode";
  actionSujet.data = sujetNode[0];
  //  actionsToSendTemp.push(actionSujet);
  //    this.addAction(actionSujet);

  var actionObjet = {};
  actionObjet.type = "newNode";
  actionObjet.data = objetNode[0];
  //  actionsToSendTemp.push(actionObjet);
  //  this.addAction(actionObjet);


  // maintenant, on peut ajouter l'edge
  this.network.body.data.edges.add({
    label: message[1],
    from : sujetNode[0].id,
    to : objetNode[0].id
  });

  //on récupère ce edge pour l'envoyer au serveur
  var edge = this.network.body.data.edges.get({
    filter: function(edge) {
      return (edge.from == sujetNode[0].id && edge.to == objetNode[0].id && edge.label == message[1]);
    }
  });
  var actionEdge = {};
  actionEdge.type = "newEdge";
  actionEdge.data = edge;
  //  this.addAction(actionEdge);
  let actionstosend = [];
  actionstosend.push(actionSujet);
  actionstosend.push(actionObjet);
  actionstosend.push(actionEdge);
  this.agentGraph.send('agentSocket', {type: "newActions", actions: actionstosend});

  //  actionsToSendTemp.push(actionEdge);
  //console.log(actionsToSendTemp);
  //  return actionsToSendTemp;
}

exportJson() {
  var network = this.network;
  console.log(network)
  var filename = prompt("Sous quel nom sauvegarder ce graphe ?", "Spoggy");
  //  app.$.inputMessage.value = '';
  if (filename == null || filename == "") {
    txt = "User cancelled the prompt.";
    return;
  }
  var textToWrite = "";
  var fileNameToSaveAs = filename+"_spoggy_nodes_edges_" + Date.now() + ".json";
  var textFileAsBlob = "";

  console.log("export Json");
  console.log(network.body.data);
  var nodes_edges = { nodes: network.body.data.nodes.get(), edges: network.body.data.edges.get() };
  console.log(nodes_edges);
  var nodes_edgesJSON = JSON.stringify(nodes_edges);
  console.log(nodes_edgesJSON);
  textFileAsBlob = new Blob([nodes_edgesJSON], {
    type:
    'application/json'
  }
);
var downloadLink = document.createElement("a");
downloadLink.download = fileNameToSaveAs;
downloadLink.innerHTML = "Download File";
if(navigator.userAgent.indexOf("Chrome") != -1)
{
  // Chrome allows the link to be clicked
  // without actually adding it to the DOM.
  console.log("CHROME");
  downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
} else
{
  // Firefox requires the link to be added to the DOM
  // before it can be clicked.
  console.log("FF");
  downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
  downloadLink.target="_blank";
  //downloadLink.onclick = destroyClickedElement;
  //downloadLink.onclick = window.URL.revokeObjectURL(downloadLink);
  downloadLink.style.display = "none";
  document.body.appendChild(downloadLink);
  //  console.log(app.$.popupTtl);
}
console.log(downloadLink);
/*downloadLink.click();*/
/* creation d'un event car download.click() ne fonctionne pas sous Firefox */
var event = document.createEvent("MouseEvents");
event.initMouseEvent(
  "click", true, false, window, 0, 0, 0, 0, 0
  , false, false, false, false, 0, null
);
downloadLink.dispatchEvent(event);
var app = this;
setTimeout(function(){
  console.log(downloadLink.parentNode);
  document.body.removeChild(downloadLink);
  window.URL.revokeObjectURL(downloadLink);
}, 1000);
/*if (window.URL != null) {
// Chrome allows the link to be clicked
// without actually adding it to the DOM.
downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
} else {
// Firefox requires the link to be added to the DOM
// before it can be clicked.
downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
downloadLink.onclick = destroyClickedElement;
downloadLink.style.display = "none";
document.body.appendChild(downloadLink);
}
downloadLink.click();*/
}



exportTtl() {
  /* source https://github.com/scenaristeur/dreamcatcherAutonome/blob/master/autonome/public/agents/ExportAgent.js */
  let network = this.network;
  var nodes = network.body.data.nodes.get();
  var edges = network.body.data.edges.get();
  console.log("exportation");
  console.log(nodes);
  console.log(edges);
  //creation des statements (triplets)
  /*var statements = [];
  for (var j = 0; j < edges.length; j++){
  var edge = edges[j];
  console.log(edge);
  statements.push({sujet: node.id, propriete: "rdfs:label", objet: node.label});
}
console.log(statements);*/

var output = "@prefix : <http://smag0.blogspot.fr/spoggy#> . \n";
output += "@prefix owl: <http://www.w3.org/2002/07/owl#> . \n";
output += "@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . \n";
output += "@prefix xml: <http://www.w3.org/XML/1998/namespace> . \n";
output += "@prefix xsd: <http://www.w3.org/2001/XMLSchema#> . \n";
output += "@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . \n";
output += "@prefix smag: <http://smag0.blogspot.fr/spoggy#> . \n";
output += "@base <http://smag0.blogspot.fr/spoggy> . \n";
output += "<http://smag0.blogspot.fr/spoggy> rdf:type owl:Ontology ;  \n";
output += "                    owl:versionIRI <http://smag0.blogspot.fr/spoggy/1.0.0> . \n";
output += " \n";
output += "owl:Class rdfs:subClassOf owl:Thing .  \n";

var listeInfos = new Array();
var listeComplementaire = new Array();

for (var i = 0; i < edges.length; i++) {
  var edge = edges[i];

  var sujet = edge.from;
  var propriete = edge.label;
  var objet = edge.to;


  //string.indexOf(substring) > -1
  //console.log(sujet);
  //console.log(propriete);
  //  console.log(objet);

  // AJOUTER EVENTUELLEMENT LA RECUPERATION DE SHAPE, COLOR, pour l'export RDF
  var sujetLabel = network.body.data.nodes.get(sujet).label;
  var objetLabel = network.body.data.nodes.get(objet).label;
  //console.log("#########################");
  //console.log(sujetLabel);
  //console.log(objetLabel)
  //console.log("#########################");

  var sujetWithPrefix = this.validRdf(network, sujet);
  var proprieteWithPrefix = this.validRdf(network, propriete);
  var objetWithPrefix = this.validRdf(network, objet);

  if (sujetWithPrefix.indexOf(':') == -1) { // ne contient pas de ':'
  sujetWithPrefix = ':' + sujetWithPrefix;
}

if (proprieteWithPrefix.indexOf(':') == -1) { // ne contient pas de ':'
proprieteWithPrefix = ':' + proprieteWithPrefix;

}

if (objetWithPrefix.indexOf(':') == -1) { // ne contient pas de ':'
objetWithPrefix = ':' + objetWithPrefix;
}


var typedeProp = ["owl:AnnotationProperty", "owl:ObjectProperty", "owl:DatatypeProperty"];
var indiceTypeDeProp = 1; // -1 pour ne pas ajouter la prop, sinon par defaut en annotationProperty, 1 pour Object, 2 pour Datatype --> revoir pour les datatypes

if ((proprieteWithPrefix == "type") || (proprieteWithPrefix == ":type") || (proprieteWithPrefix == "rdf:type")) {
  proprieteWithPrefix = "rdf:type";
  listeComplementaire.push(objetWithPrefix + " rdf:type owl:Class . \n");
  indiceTypeDeProp = 1;


} else if ((proprieteWithPrefix == "subClassOf") || (proprieteWithPrefix == ":subClassOf") || (proprieteWithPrefix == "rdfs:subClassOf")) {
  proprieteWithPrefix = "rdfs:subClassOf";

}
else if ((proprieteWithPrefix == "sameAs") || (proprieteWithPrefix == ":sameAs")) {
  proprieteWithPrefix = "owl:sameAs";
  indiceTypeDeProp = -1;
}
else if ((proprieteWithPrefix.toLowerCase() == "ispartof") || (proprieteWithPrefix.toLowerCase() == "partof") || (proprieteWithPrefix.toLowerCase() == ":ispartof") || (proprieteWithPrefix.toLowerCase() == ":partof") || (proprieteWithPrefix.toLowerCase() == ":ispartof")) {
  proprieteWithPrefix = "smag:partOf";
  indiceTypeDeProp = 1;

} else if ((proprieteWithPrefix.toLowerCase() == "comment") || (proprieteWithPrefix.toLowerCase() == "commentaire") || (proprieteWithPrefix.toLowerCase() == "//") || (proprieteWithPrefix.toLowerCase() == "#")) {
  proprieteWithPrefix = "rdfs:comment";
  indiceTypeDeProp = -1;

}


if (indiceTypeDeProp >= 0) {
  listeComplementaire.push(proprieteWithPrefix + " rdf:type " + typedeProp[indiceTypeDeProp] + " . \n");
}
var data = sujetWithPrefix + " " + proprieteWithPrefix + " " + objetWithPrefix + " . \n";
data += sujetWithPrefix + " " + "rdfs:label \"" + sujetLabel + "\" . \n";
data += objetWithPrefix + " " + "rdfs:label \"" + objetLabel + "\" . \n";
listeInfos[i] = data;
console.log(data);
console.log("||||||||||||||||||||||--");
}
//console.log(listeInfos);
//console.log(listeComplementaire);
//suppression des doublons
listeInfos = uniq_fast(listeInfos.sort());
listeComplementaire = uniq_fast(listeComplementaire.sort());
// console.log (listeInfos);
for (var k = 0; k < listeInfos.length; k++) {
  output = output + listeInfos[k];
  //  console.log(output);
}

for (var l = 0; l < listeComplementaire.length; l++) {
  output = output + listeComplementaire[l];
  //  console.log(output);
}


this.$.inputTextToSave.value = output; //     document.getElementById("inputTextToSave").value =output;
/*this.$.popupTtl.fitInto = this.$.menu;*/
this.$.popupTtl.toggle();
}


newGraph(){
  //network.body.data.nodes.clear();
  //network.body.data.edges.clear();
  let network = this.network;

  var graphname = prompt("Comment nommer ce nouveau graphe ?", "Spoggy-Graph_"+Date.now());
  var nodeName = {
    label: graphname,
    shape: "star",
    color: "green",
    type: "node"
  };
  var nodeGraph = {
    label: "Graph",
    /*    shape: "star",
    color: "red",*/
    type: "node"
  };
  network.body.data.nodes.clear();
  network.body.data.edges.clear();
  var nodes = network.body.data.nodes.add([nodeName, nodeGraph]);

  var edge = {
    from: nodes[0],
    to: nodes[1],
    arrows: "to",
    label: "type"
  }
  network.body.data.edges.add(edge);
  /* seulement en cas de synchro, mais difficile de newgrapher en synchro ?
  var action = {};
  action.type = "newNode";
  action.data = nodeName;
  this.addAction(action);

  action = {};
  action.type = "newNode";
  action.data = nodeGraph;
  this.addAction(action);

  action = {};
  action.type = "newEdge";
  action.data = edge;
  this.addAction(action);

  action = {};
  action.type = "changeGraph";
  action.data = graphname;
  this.addAction(action);
  if(app.socket != undefined){
  app.socket.graph = graphname;
  console.log(app.socket);
}
*/

//app.socket.emit('newGraph', graphname);
/*
//document.getElementById('importPopUp').style.display = 'block';
app.$.importPopUp.style.display = 'block';

var filepicker = app.$.filepicker;
filepicker.addEventListener('change', handleFileSelect.bind(app), false);
filepicker.network = network;*/
}

validRdf(network, string){
  // A REVOIR
  console.log(network.body.data.nodes.get(string));
  console.log("nettoyage "+ string);
  // transformer le noeud en noeud rdf (resource ou literal)
  // ajouter la construction du noeud, son uri, prefix, localname, type...
  var valid = {};
  valid.type = "uri";
  if (string.indexOf(" ") !== -1){
    valid.type = "literal";
  }else{
    /*
    replaceAll(string, " ","_");
    replaceAll(string, "","_");
    replaceAll(string, ",","_");
    replaceAll(string, ";","_");
    replaceAll(string, " ","_");*/
  }

  return string;
}


decortiqueFile(fichier, remplaceNetwork){
  //  var network = network;
  //  console.log(network);
  let network = this.network;
  //  console.log(fichier);
  var reader = new FileReader(); //https://openclassrooms.com/courses/dynamisez-vos-sites-web-avec-javascript/l-api-file
  reader.addEventListener('load', function () {
    //  console.log(fichier);
    /*loadstart : La lecture vient de commencer.
    progress : Tout comme avec les objets XHR, l'événement progress se déclenche à intervalles réguliers durant la progression de la lecture. Il fournit, lui aussi, un objet en paramètre possédant deux propriétés, loaded et total, indiquant respectivement le nombre d'octets lus et le nombre d'octets à lire en tout.
    load : La lecture vient de se terminer avec succès.
    loadend : La lecture vient de se terminer (avec ou sans succès).
    abort : Se déclenche quand la lecture est interrompue (avec la méthode abort() par exemple).
    error : Se déclenche quand une erreur a été rencontrée. La propriété error contiendra alors un objet de type FileError pouvant vous fournir plus d'informations.*/
    //    console.log(this.result);
    //alert('Contenu du fichier "' + fichier.name + '" :\n\n' + reader.result);


    switch (fichier.type) {
      case "":
      case "text/plain":
      case "application/json":
      //    console.log("JSON");
      //  thisElement.dispatch('addNodesEdgesJSON', JSON.parse(reader.result));
      //    console.log(network);
      var nodes = JSON.parse(reader.result).nodes;
      //    console.log(nodes);
      var edges = JSON.parse(reader.result).edges;
      //    console.log(edges);
      network.beforeImport = [];
      network.beforeImport.nodes = network.body.data.nodes.get();
      network.beforeImport.edges = network.body.data.edges.get();
      network.body.data.nodes.update(nodes);
      network.body.data.edges.update(edges);
      if(remplaceNetwork){
        console.log(remplaceNetwork);
        network.body.data.nodes.clear();
        network.body.data.edges.clear();
        console.log("clear");
        network.body.data.nodes.add(nodes); // clear() ne semble pas fonctionner, à revoir
        network.body.data.edges.add(edges);
        console.log(network);
      }else{

        try{
          network.body.data.nodes.update(nodes);
          network.body.data.edges.update(edges);
        }
        catch(e){
          console.log(e);
        }
      }
      console.log(network);
      //  console.log(partageImport);
      break;
      case "rdf+xml":
      case "application/rdf+xml":
      console.log("fichier RDF"); //https://github.com/scenaristeur/dreamcatcherAutonome/blob/8376cb5211095a90314e34e9d286b820fbed335b/autonome1/public/agents/FichierAgent.js
      rdf2Xml(reader.result, network);
      //  network.dispatch('addTriplets', network.triplets);// CREER UNE NOUVELLE ACTION POUR ENVOYER TS LES TRIPLETS
      break;
      case "turtle":
      case "text/turtle":
      case "application/turtle":
      console.log("fichier turtle");
      console.log("ce type de fichier n'est pas pris en compte (" + fichier.type + ")");
      ttl2Xml(reader.result, network);
      //network.dispatch('addTriplets', network.triplets);
      break;
      default:
      console.log("ce type de fichier n'est pas pris en compte (" + fichier.type + ")");
      var extension = fichier.name.split('.').pop();
      console.log(extension);
      console.log(fichier);
      //  console.log(reader.result);
      if ((extension == "ttl") || (extension == "n3") || (extension == "n3t")) {
        //   sketch.ttl2Xml(reader.result);
        ttl2Xml(reader.result, network);
        //  network.dispatch('addTriplets', network.triplets);
      } else if ((extension == "rdf") || (extension == "owl")) {
        //  sketch.data2Xml(reader.result); //if srdf
        rdf2Xml(reader.result, network);
        //  network.dispatch('addTriplets', network.triplets);
      }
      else if ((extension == "json") || (reader.result.startsWith("[{"))) {
        // json2Xml(reader.result);
        //  network.dispatch('addNodesEdgesJSON', JSON.parse(reader.result));
      } else {
        data2Xml(reader.result, network);
      }
      console.log("fichier lu");
    }

    // thisApp.dispatch('update_triplets2add', this.triplets2add);

  });
  console.log(fichier);

  reader.readAsText(fichier);
}

}
});
</script>




<script>
/* @polymerMixin */
var GraphBehaviorMixin = Polymer.dedupingMixin(function(superClass){
  return class GraphBehavior extends superClass {
    constructor() {
      super();
    }
    static get properties() {
      return {
        test: {
          type: String,
          value: 'spoggy-graph behavior'
        },
        network: {
          type: Object,
          notify: true
        },
        init: {
          type: Object,
          value : {"nodes":[{"id":"node1","label":"S P O G G Y","color":"rgb(0, 255, 0)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{"enabled":false}},"shadow":{"enabled":false},"shapeProperties":{},"x":19,"y":-34,"shape":"circle","type":"node","size":30.66552734375},{"id":"node2","label":"WebApp","color":"rgba(97,238,195,0.5)"},{"id":"node3","label":"David"},{"id":"node5","label":"Graph","color":"rgba(195, 238, 97, 1)","cid":2,"fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":-64.14842927153691,"y":-383.799200452315,"shape":"ellipse","type":"node"},{"id":"node6","label":"Spoggy est une application multiutilisateurs\n permettant la création de graphes de connaissance.\n Cliquez sur le bouton Edit\n pour ajouter / modifier un noeud ou un lien.","color":"rgba(238,97,195,0.5)","shape":"box","cid":1},{"id":"node7","label":"Description","color":"rgba(238,97,195,0.5)","cid":1},{"id":"node8","label":"Un graphe est un ensemble de noeuds\n et de liens entre ces noeuds.","color":"rgba(238,97,195,0.5)","shape":"box","cid":1},{"id":"node12","label":"Input","color":"rgba(194, 236, 98, 1)","cid":2,"fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{"enabled":false}},"shadow":{"enabled":false},"shapeProperties":{},"x":228.34807896168763,"y":307.4952402096294,"shape":"ellipse","type":"node"},{"label":"Saisir des Triplets","id":"c7b8d105-3805-4f25-8696-506e2b1ac798","color":"rgb(173,208,255)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":-182.9941341203914,"y":430.7021540883557,"shape":"ellipse","type":"node"},{"label":"Saisir des Commandes","id":"5fa743f2-8abe-4423-94ef-7cd6e3f3e5c7","color":"rgb(173,208,255)","fixed":{"x":false,"y":false},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":183.02365403475693,"y":210.1028693512441,"shape":"ellipse","type":"node"},{"label":"Commandes Spoggy","id":"ecd51df3-c8a1-44c0-9ce4-50283418ea24","color":"rgb(173,208,255)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":451.855838695271,"y":96.41648185062448,"shape":"ellipse","type":"node"},{"label":"\"/h\"","id":"4339d194-bda1-4f7f-95d0-115e9f29f89f","color":"rgb(238, 98, 98)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":814.0145513882942,"y":267.54384912339185,"shape":"ellipse","type":"node"},{"label":"\"/n\"","id":"bcb456c7-8ad1-4262-81ce-fa3b279fd6e7","color":"rgb(238, 98, 98)","fixed":{"x":false,"y":false},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":493.5035838986795,"y":-300.3342379340666,"shape":"ellipse","type":"node"},{"label":"\"/e\"","id":"19728f3e-6003-4c4f-b386-81d67f796987","color":"rgb(238, 98, 98)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":1097.2536737715066,"y":-251.1842023937666,"shape":"ellipse","type":"node"},{"label":"\"/i\"","id":"b000f137-57f9-4f75-ad2f-25ec5707f1a0","color":"rgb(238, 98, 98)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":1094.9467539506354,"y":78.41497340303215,"shape":"ellipse","type":"node"},{"label":"\"/t\"","id":"d04c571c-9674-405a-b9ba-f5cde35f7af5","color":"rgb(238, 98, 98)","fixed":{"x":false,"y":false},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":826.9566920362134,"y":-442.6852032018555,"shape":"ellipse","type":"node"},{"label":"TripletSpoggy","id":"c2c524b0-159b-476e-ac87-ef661b1859ad","color":"rgb(173, 208, 255)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":-252.20454854271725,"y":544.4634154325607,"shape":"ellipse","type":"node"},{"id":"6061ad47-d16d-47be-b85f-6973714cac78","x":-371,"y":895,"label":"David habite Lyon,","shape":"ellipse","color":"rgb(255, 128, 0)","type":"node","fixed":{"x":false,"y":false},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{"enabled":false}},"shadow":{"enabled":false},"shapeProperties":{}},{"id":"df2286a2-0831-4d7e-a2da-2d68ce00a837","x":-58.95037829687396,"y":777.1869301921975,"label":"David habite Lyon;","shape":"ellipse","color":"rgb(255, 128, 0)","type":"node","fixed":{"x":false,"y":false},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{"enabled":false}},"shadow":{"enabled":false},"shapeProperties":{}},{"id":"12615d9b-b16e-4869-a72d-01200198d94e","x":-308,"y":342,"label":"David habite Lyon.","shape":"ellipse","color":"rgb(255, 128, 0)","type":"node","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{"enabled":false}},"shadow":{"enabled":false},"shapeProperties":{}},{"label":"Importer un fichier Spoggy","id":"d7eec24e-6fff-4e3d-a2e5-2ec433a7cda9","color":"rgb(173,208,255)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":898.0106787303208,"y":189.11515148330028,"shape":"ellipse","type":"node"},{"label":"Exporter au format Turtle (voir l'aide)","id":"3651ca09-4753-4f17-871b-1cb2c1811d54","color":"rgb(173,208,255)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":768.9706973989651,"y":-238.63883507575244,"shape":"ellipse","type":"node"},{"label":"Exporter au format Json-Spoggy","id":"2e5bf0e6-98d5-4a73-b596-fecdcb26f5cb","color":"rgb(173,208,255)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":404.4623814822494,"y":-374.5590854974655,"shape":"ellipse","type":"node"},{"label":"Créer un nouveau graphe","id":"f1489465-f65b-4121-9473-d6c875754c60","color":"rgb(173,208,255)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":150.14320251420511,"y":-234.89360482799893,"shape":"ellipse","type":"node"},{"label":"Afficher l' aide","id":"d54e99d4-83e4-4af6-b0f3-ff58348fb4ff","color":"rgb(173, 208, 255)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":312.28425758055437,"y":530.920049384247,"shape":"ellipse","type":"node"},{"label":"Developpeur","id":"9b4524fa-9d88-4a8d-b7c8-78d124f404c5"},{"label":"Personne","id":"d1153ea1-2c66-42fd-8eaf-d131452dfab1"},{"id":"fcb0d058-b6af-4ad7-ac43-4f99643c3d46","x":-777.6365653663045,"y":14.885417551608791,"label":"Ajouter un noeud","shape":"ellipse","color":"rgb(173, 208, 255)","type":"node"},{"id":"56dfc244-2106-447e-bdc2-6eaef39162f0","x":-832.1605743169799,"y":-78.007338438431,"label":"Ajouter un lien","shape":"ellipse","color":"rgb(173,208,255)","type":"node"},{"id":"df3ef4f9-6082-4e67-bdaa-d209b2fa278e","x":-936.1600728710463,"y":-222.39499177077548,"label":"Editer le noeud","shape":"ellipse","color":"rgb(173,208,255)","type":"node"},{"id":"7a2cc2a6-7ef0-4139-8e4e-0b2d02c49aef","x":-934.1406651321323,"y":-291.05485489384836,"label":"Effacer la sélection","shape":"ellipse","color":"rgb(173,208,255)","type":"node"},{"id":"0d751301-6b67-447c-a868-17a50539f5f8","x":-450.5540526133564,"y":-362.095456078989,"label":"Bouton Editer","shape":"ellipse","color":"rgb(255, 0, 128)","type":"node","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{"enabled":false}},"shadow":{"enabled":false},"shapeProperties":{}},{"id":"5cbe8edc-9a1c-4c85-a0a3-358bcdd618ad","x":-1232.003306621934,"y":-264.80255428796755,"label":"Editer le lien","shape":"ellipse","color":"rgb(173,208,255)","type":"node"},{"label":"Triplet","id":"086bc0c3-a5aa-469c-b4e9-a7858e546395"},{"label":"Sujet","id":"448fd959-4836-4816-9af4-61ae75886bdf"},{"label":"Objet","id":"d9a2a491-716b-479a-8114-1918b88c9927"},{"label":"Predicat","id":"d6cf0f3a-5dcb-4e34-aebc-df271e432dbe"},{"label":"Noeud","id":"eab5c5e1-aa63-41d7-a7a9-bfceaff13391"},{"label":"Lien","id":"d24d7cce-e693-49d7-8948-8b19ee105763"},{"id":"1a02510c-a95b-41c1-8bfb-d7056bab7e30","x":-66.49914007052806,"y":542.0274242149706,"label":"se termine par une virgule","shape":"ellipse","color":"rgb(173, 208, 255)","type":"node"},{"label":"se termine par un point-virgule","id":"f19405b8-949a-449e-a5f6-a6131ee09463"},{"label":"se termine par un point","id":"e898479f-d503-45f8-b240-0067760d2f3f"},{"id":"02aa32b3-cf56-4096-85c9-ec40b29b980c","x":266.5737811255209,"y":569.1439399754726,"label":"3 mots une virgule et Entrée","shape":"ellipse","color":"rgb(0, 255, 0)","type":"node"},{"label":"Menu Droit de boutons","id":"8bbf9054-04bd-4ed3-96a3-585165b8687e","color":"rgb(255, 0, 128)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{"enabled":false}},"shadow":{"enabled":false},"shapeProperties":{},"x":514.8156906913355,"y":-152.99092704081667,"shape":"ellipse","type":"node"},{"label":"bouton ?","id":"c91a0595-dfff-4711-b041-07548b49d51b","color":"rgb(255, 0, 128)","fixed":{},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{"enabled":false}},"shadow":{"enabled":false},"shapeProperties":{},"x":146,"y":-308,"shape":"ellipse","type":"node"},{"label":"Bouton Selection du mode","id":"0bf8aa6d-9706-48ba-9731-7f6ba2e4c05a","color":"rgb(255, 0, 128)","fixed":{"x":false,"y":false},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":524.7813631630936,"y":320.7627642625145,"shape":"ellipse","type":"node"},{"label":"Bouton Réglages","id":"b612d845-319d-4955-adee-8f76171a46db","color":"rgb(255, 0, 128)","fixed":{"x":false,"y":false},"font":{"bold":{},"boldital":{},"ital":{},"mono":{}},"icon":{},"margin":{},"scaling":{"label":{}},"shadow":{},"shapeProperties":{},"x":819.7906319686404,"y":5.830823236116829,"shape":"ellipse","type":"node"},{"label":"Régler la distance entre les noeuds, la force des liens...","id":"761ad6eb-0a68-4500-8894-f8857dd02e0c"},{"label":"Mode Solo","id":"97cc10ea-845e-455e-bf69-02551296c214"},{"label":"Mode Collab","id":"a923f591-5100-4892-ac95-7e72fc1dc436"},{"label":"Mode Global","id":"779087a9-074b-4cff-b0dd-9f1e5263b12e"},{"label":"un endpoint sparql fuseki","id":"86a24ad5-c6aa-4392-8417-955af798b553"},{"label":"Créer des graphes de manière collaborative en temps réel","id":"6f1ca3ed-180f-4aff-8a35-8c01f75f49df"}],"edges":[{"from":"node1","to":"node2","label":"type","array":"to","id":"cb414426-dd23-4f43-ade9-b8517f73ce22"},{"from":"node1","to":"node3","label":"developpeur","array":"to","id":"80709905-51e7-4d4c-acd8-4aea6eaaee89"},{"from":"node1","to":"node5","label":"hasPart","array":"to","id":"06e37e6d-be24-4570-b94b-8ab9a3777ad5"},{"from":"node1","to":"node12","label":"hasPart","array":"to","id":"2de3daf9-a751-4ec2-ad3a-5f5bb7dfa3a1"},{"from":"node1","to":"node6","label":"description","array":"to","id":"8b58fa88-2c77-4809-bb44-0062e4318c4a"},{"from":"node6","to":"node7","label":"type","array":"to","id":"5f6ac88a-2ac8-4817-887a-6c042cebf2cf"},{"from":"node5","to":"node8","label":"description","array":"to","id":"62dec174-572d-476d-bf85-2cf146430578"},{"from":"node8","to":"node7","label":"type","array":"to","id":"a96a7a93-f27d-4f0b-a67c-6714922fd865"},{"label":"permet","from":"node12","to":"c7b8d105-3805-4f25-8696-506e2b1ac798","id":"9f7c051a-ee90-477c-a250-e39894ab46d5"},{"label":"permet de","from":"node12","to":"5fa743f2-8abe-4423-94ef-7cd6e3f3e5c7","id":"0fc9fd06-b5fb-4822-83f1-ca2c515a2900"},{"label":"concerne","from":"5fa743f2-8abe-4423-94ef-7cd6e3f3e5c7","to":"ecd51df3-c8a1-44c0-9ce4-50283418ea24","id":"4e230d33-4134-49c5-96d8-0f429d9d0b34"},{"label":"type","from":"4339d194-bda1-4f7f-95d0-115e9f29f89f","to":"ecd51df3-c8a1-44c0-9ce4-50283418ea24","id":"c4a69635-00e8-4c6e-804f-465bf36e4f94"},{"label":"type","from":"bcb456c7-8ad1-4262-81ce-fa3b279fd6e7","to":"ecd51df3-c8a1-44c0-9ce4-50283418ea24","id":"592ff327-d9a9-45a0-8b45-ee491d8c6d41"},{"label":"type","from":"19728f3e-6003-4c4f-b386-81d67f796987","to":"ecd51df3-c8a1-44c0-9ce4-50283418ea24","id":"15e30b96-8c0d-45a0-b3b2-54b681b4e64c"},{"label":"type","from":"b000f137-57f9-4f75-ad2f-25ec5707f1a0","to":"ecd51df3-c8a1-44c0-9ce4-50283418ea24","id":"f141aa15-4893-41ea-ae1b-f59e5698405d"},{"label":"type","from":"d04c571c-9674-405a-b9ba-f5cde35f7af5","to":"ecd51df3-c8a1-44c0-9ce4-50283418ea24","id":"db1edd52-a6da-4da7-aa94-63678af1b369"},{"label":"concerne","from":"c7b8d105-3805-4f25-8696-506e2b1ac798","to":"c2c524b0-159b-476e-ac87-ef661b1859ad","id":"7436eef0-c1f5-4915-a485-2fae6eb4a512"},{"from":"6061ad47-d16d-47be-b85f-6973714cac78","to":"c2c524b0-159b-476e-ac87-ef661b1859ad","label":"type","id":"7c49777c-8301-45ac-83bc-acb56f00d151"},{"from":"df2286a2-0831-4d7e-a2da-2d68ce00a837","to":"c2c524b0-159b-476e-ac87-ef661b1859ad","label":"type","id":"41e4b112-0102-4dfc-9849-e2277e67056e"},{"from":"12615d9b-b16e-4869-a72d-01200198d94e","to":"c2c524b0-159b-476e-ac87-ef661b1859ad","label":"type","id":"8b9f933e-e822-4358-825a-09eaa928a182"},{"label":"description","from":"b000f137-57f9-4f75-ad2f-25ec5707f1a0","to":"d7eec24e-6fff-4e3d-a2e5-2ec433a7cda9","id":"2306487d-78fe-4a6f-9a28-41b51b44616e"},{"label":"description","from":"d04c571c-9674-405a-b9ba-f5cde35f7af5","to":"3651ca09-4753-4f17-871b-1cb2c1811d54","id":"9d25583f-c749-4f4e-8803-007407cbb645"},{"label":"description","from":"19728f3e-6003-4c4f-b386-81d67f796987","to":"2e5bf0e6-98d5-4a73-b596-fecdcb26f5cb","id":"e6681ada-74a6-42a2-9d71-0fb26b93fb4f"},{"label":"description","from":"bcb456c7-8ad1-4262-81ce-fa3b279fd6e7","to":"f1489465-f65b-4121-9473-d6c875754c60","id":"e97888c2-1afc-4988-b9dc-2b6621c4455b"},{"label":"description","from":"4339d194-bda1-4f7f-95d0-115e9f29f89f","to":"d54e99d4-83e4-4af6-b0f3-ff58348fb4ff","id":"3ea06ec3-5793-4a78-9947-22483b99e1fb"},{"label":"type","from":"node3","to":"9b4524fa-9d88-4a8d-b7c8-78d124f404c5","id":"6f66c1e6-86b5-4613-8546-efca75b474e7"},{"label":"subClassOf","from":"9b4524fa-9d88-4a8d-b7c8-78d124f404c5","to":"d1153ea1-2c66-42fd-8eaf-d131452dfab1","id":"2afadcfa-2f65-42de-8e7d-e98c6a4560c4"},{"from":"df2286a2-0831-4d7e-a2da-2d68ce00a837","to":"node3","label":"concerne","id":"61113760-a6e4-4777-a467-03c4d6e8c171"},{"from":"6061ad47-d16d-47be-b85f-6973714cac78","to":"node3","label":"concerne","id":"d6ee92ed-9360-46f9-b136-253bf97de249"},{"from":"12615d9b-b16e-4869-a72d-01200198d94e","to":"node3","label":"concerne","id":"02f45ea2-5c36-4c18-be8c-e6997c25f1bb"},{"from":"0d751301-6b67-447c-a868-17a50539f5f8","to":"fcb0d058-b6af-4ad7-ac43-4f99643c3d46","label":"procure","id":"3b394153-bbbc-4bf2-a0e5-ce33b211d32d"},{"from":"0d751301-6b67-447c-a868-17a50539f5f8","to":"56dfc244-2106-447e-bdc2-6eaef39162f0","label":"procure","id":"4a1ad5ab-0393-43c7-b996-dadc891663fb"},{"from":"0d751301-6b67-447c-a868-17a50539f5f8","to":"7a2cc2a6-7ef0-4139-8e4e-0b2d02c49aef","label":"procure","id":"0affd9fb-f7b0-4424-b32e-1fd21c99c593"},{"from":"0d751301-6b67-447c-a868-17a50539f5f8","to":"df3ef4f9-6082-4e67-bdaa-d209b2fa278e","label":"procure","id":"aff9c5ee-5945-4c5d-ae8b-80653a4d16f5"},{"from":"0d751301-6b67-447c-a868-17a50539f5f8","to":"5cbe8edc-9a1c-4c85-a0a3-358bcdd618ad","label":"procure","id":"e03c30df-c5b1-4a55-a992-c49c7cba7326"},{"label":"subClassOf","from":"c2c524b0-159b-476e-ac87-ef661b1859ad","to":"086bc0c3-a5aa-469c-b4e9-a7858e546395","id":"97f6ab42-1f02-4fb4-809f-3b84ae4ba7d4"},{"label":"représentéPar","from":"448fd959-4836-4816-9af4-61ae75886bdf","to":"eab5c5e1-aa63-41d7-a7a9-bfceaff13391","id":"04116cfe-7e0d-4d82-ae65-1591eca2a1c2"},{"label":"représentéPar","from":"d9a2a491-716b-479a-8114-1918b88c9927","to":"eab5c5e1-aa63-41d7-a7a9-bfceaff13391","id":"d07d2b51-8af3-44ae-b398-797197968532"},{"label":"représentéPar","from":"d6cf0f3a-5dcb-4e34-aebc-df271e432dbe","to":"d24d7cce-e693-49d7-8948-8b19ee105763","id":"9e577997-0456-4f4b-b3e3-3da964de25b3"},{"from":"f1489465-f65b-4121-9473-d6c875754c60","to":"node5","label":"concerne","id":"44d0595b-edb1-4a4f-9ce5-f37537a2fb17"},{"from":"fcb0d058-b6af-4ad7-ac43-4f99643c3d46","to":"eab5c5e1-aa63-41d7-a7a9-bfceaff13391","label":"concerne","id":"80463227-ff6b-47c0-9de0-7c7a70954305"},{"from":"df3ef4f9-6082-4e67-bdaa-d209b2fa278e","to":"eab5c5e1-aa63-41d7-a7a9-bfceaff13391","label":"concerne","id":"a67e17e1-d772-42e2-bde9-d3c78e2bcd95"},{"from":"5cbe8edc-9a1c-4c85-a0a3-358bcdd618ad","to":"d24d7cce-e693-49d7-8948-8b19ee105763","label":"concerne","id":"07e3a92a-6a6f-4f71-82a1-343de9109113"},{"from":"7a2cc2a6-7ef0-4139-8e4e-0b2d02c49aef","to":"eab5c5e1-aa63-41d7-a7a9-bfceaff13391","label":"concerne","id":"34753145-b04e-4dca-953c-e5ceec0f72c3"},{"from":"7a2cc2a6-7ef0-4139-8e4e-0b2d02c49aef","to":"d24d7cce-e693-49d7-8948-8b19ee105763","label":"concerne","id":"30e2c58e-d190-497d-995f-cd74027afafe"},{"from":"56dfc244-2106-447e-bdc2-6eaef39162f0","to":"d24d7cce-e693-49d7-8948-8b19ee105763","label":"concerne","id":"2b0afa06-7b81-4174-be64-5652ff7bcd45"},{"from":"node3","to":"448fd959-4836-4816-9af4-61ae75886bdf","label":"type","id":"1c873d56-6f10-494c-a8ca-2315757b88d1"},{"from":"2e5bf0e6-98d5-4a73-b596-fecdcb26f5cb","to":"d7eec24e-6fff-4e3d-a2e5-2ec433a7cda9","label":"next","id":"fc785f1e-7743-46ec-8a71-09eea6b136bf"},{"from":"6061ad47-d16d-47be-b85f-6973714cac78","to":"1a02510c-a95b-41c1-8bfb-d7056bab7e30","label":"particularité","id":"eea0c40b-0139-48d6-b6ea-cc2d12a41d26"},{"label":"particularité","from":"df2286a2-0831-4d7e-a2da-2d68ce00a837","to":"f19405b8-949a-449e-a5f6-a6131ee09463","id":"011189fb-5614-4961-bee5-b791b6dbafb0"},{"label":"particularité","from":"12615d9b-b16e-4869-a72d-01200198d94e","to":"e898479f-d503-45f8-b240-0067760d2f3f","id":"a6a7b935-33c5-4591-ad47-4192ddca0888"},{"from":"c7b8d105-3805-4f25-8696-506e2b1ac798","to":"02aa32b3-cf56-4096-85c9-ec40b29b980c","label":"first","id":"86189024-5aa7-466a-bd36-12cf37548094"},{"from":"02aa32b3-cf56-4096-85c9-ec40b29b980c","to":"node12","label":"emplacement","id":"e4573917-ac0c-4b78-9bff-ae430e1ec09b"},{"from":"02aa32b3-cf56-4096-85c9-ec40b29b980c","to":"6061ad47-d16d-47be-b85f-6973714cac78","label":"exemple","id":"4da925c6-7b72-4ed6-8f24-fcbd6528c79f"},{"label":"hasPart","from":"node1","to":"8bbf9054-04bd-4ed3-96a3-585165b8687e","id":"d56264fe-b632-48b5-ab27-d11a57e95eae"},{"label":"hasPart","from":"8bbf9054-04bd-4ed3-96a3-585165b8687e","to":"c91a0595-dfff-4711-b041-07548b49d51b","id":"3afec31a-dcdb-433b-89b3-7fcd2ace2993"},{"label":"hasPart","from":"8bbf9054-04bd-4ed3-96a3-585165b8687e","to":"0bf8aa6d-9706-48ba-9731-7f6ba2e4c05a","id":"90abe54c-bb99-4e2c-9414-a94ae00f6ec0"},{"label":"hasPart","from":"8bbf9054-04bd-4ed3-96a3-585165b8687e","to":"b612d845-319d-4955-adee-8f76171a46db","id":"c94ba64d-f7de-4d66-a838-fa7dd74b981c"},{"label":"permet de","from":"b612d845-319d-4955-adee-8f76171a46db","to":"761ad6eb-0a68-4500-8894-f8857dd02e0c","id":"ef6cab17-a8a9-4897-a3f8-e2716c5db060"},{"label":"ajoute au mode Collab","from":"0bf8aa6d-9706-48ba-9731-7f6ba2e4c05a","to":"779087a9-074b-4cff-b0dd-9f1e5263b12e","id":"e1c5789a-8346-46ea-8639-4ef5043ed9ca"},{"label":"permet de se connecter à","from":"779087a9-074b-4cff-b0dd-9f1e5263b12e","to":"86a24ad5-c6aa-4392-8417-955af798b553","id":"f48f1495-db7b-4ad8-895c-4e40ef71e7bf"},{"from":"0bf8aa6d-9706-48ba-9731-7f6ba2e4c05a","to":"a923f591-5100-4892-ac95-7e72fc1dc436","label":"propose","id":"47aeae74-d9d3-49ec-a359-aac2b758dda7"},{"from":"0bf8aa6d-9706-48ba-9731-7f6ba2e4c05a","to":"97cc10ea-845e-455e-bf69-02551296c214","label":"propose","id":"fc73492b-0eb0-46fa-a844-3927fc38003f"},{"from":"a923f591-5100-4892-ac95-7e72fc1dc436","to":"6f1ca3ed-180f-4aff-8a35-8c01f75f49df","label":"ajoute au mode solo","id":"2f3861dd-db17-4fe1-b98a-7f0a641cb9da"},{"from":"c91a0595-dfff-4711-b041-07548b49d51b","to":"d54e99d4-83e4-4af6-b0f3-ff58348fb4ff","label":"permet de","id":"d6b225e2-8c3b-47e8-82f8-4dc557c8d35e"},{"from":"97cc10ea-845e-455e-bf69-02551296c214","to":"c7b8d105-3805-4f25-8696-506e2b1ac798","label":"permet de","id":"008d5780-b34e-4704-8475-189d84341c93"},{"from":"97cc10ea-845e-455e-bf69-02551296c214","to":"5fa743f2-8abe-4423-94ef-7cd6e3f3e5c7","label":"permet de","id":"0262c1f4-d2eb-4d3d-9ff7-a9c5a38938d5"},{"from":"086bc0c3-a5aa-469c-b4e9-a7858e546395","to":"448fd959-4836-4816-9af4-61ae75886bdf","label":"first","id":"3a0b1ac0-d0f6-471e-af01-b8c5b1e13163"},{"from":"086bc0c3-a5aa-469c-b4e9-a7858e546395","to":"d6cf0f3a-5dcb-4e34-aebc-df271e432dbe","label":"second","id":"6409677c-8e5d-4a76-a8db-b7b2e41c30c1"},{"from":"086bc0c3-a5aa-469c-b4e9-a7858e546395","to":"d9a2a491-716b-479a-8114-1918b88c9927","label":"troisième","id":"e65602aa-13eb-47c8-af3e-30c729a026af"},{"from":"448fd959-4836-4816-9af4-61ae75886bdf","to":"d6cf0f3a-5dcb-4e34-aebc-df271e432dbe","label":"next","id":"c938da8b-c18e-4c04-8bd5-3e2396acf58b"},{"from":"d6cf0f3a-5dcb-4e34-aebc-df271e432dbe","to":"d9a2a491-716b-479a-8114-1918b88c9927","label":"next","id":"f437967d-cf26-4399-b36b-d91f696df35f"},{"from":"node1","to":"0d751301-6b67-447c-a868-17a50539f5f8","label":"hasPart","id":"1845c34f-6756-44f2-aa69-a61fac03ce61"}]}
        }
      };
    }



    importFromParam(params){
      var source = params.source;
      var network = this.network;
      var output = [];
      var xhr = new XMLHttpRequest();
      xhr.open('GET', source, true);
      xhr.responseType = 'blob';
      xhr.onload = function(e) {
        //  console.log(e);
        var reponse = e.target.response;
        //  console.log(reponse);
        var reader = new FileReader(); //https://openclassrooms.com/courses/dynamisez-vos-sites-web-avec-javascript/l-api-file
        reader.addEventListener('load', function () {
          //  console.log(reader.result);
          // ajouter test en fonction du type de fichier, extension
          var nodes = JSON.parse(reader.result).nodes;
          //    console.log(nodes);
          var edges = JSON.parse(reader.result).edges;
          //    console.log(edges);
          network.beforeImport = [];
          network.beforeImport.nodes = network.body.data.nodes.get();
          network.beforeImport.edges = network.body.data.edges.get();
          network.body.data.nodes.update(nodes);
          network.body.data.edges.update(edges);
          try{
            network.body.data.nodes.update(nodes);
            network.body.data.edges.update(edges);
          }
          catch(e){
            console.log(e);
          }
          //  console.log(network);
          //  console.log(partageImport);
        });
        reader.readAsText(reponse);
      };
      xhr.send();
    }

    addToGraph(data){
      console.log(data)
      var app = this;
      if (data.actions.length>0){
        data.actions.forEach(function(action) {
          console.log(action);
          console.log(app.network)
          switch(action.type) {
            case "newNode":
            if(app.network != undefined){
              app.addNodeIfNotExist(app.network, action.data);
            }
            break;
            case "editNode":
            break;
            case "deleteNode":
            app.deleteFromServer(action.data);
            break;
            case "newEdge":
            if(app.network != undefined){
              app.addEdgeIfNotExist(app.network, action.data);
            }
            break;
            case "editEdge":
            break;
            case "deleteEdge":
            app.deleteFromServer(action.data);
            break;
            default:
            console.log("action non reconnue");
            console.log(action);
          }
        });
      }
    }

    resultsFromSparql(results){
      console.log("POPULATE From Sparql");
      console.log(results)
      var app = this;
      let network = this.network;
      network.body.data.nodes.clear();
      network.body.data.edges.clear();

      Object.keys(results).forEach(function(id) {
        var data = results[id];
        //  console.log(id);
        //  console.log(data)
        if (data.type == "node"){
          //A Modifier dans statements-behaviors pour envoyer dans un tableau de nodes !
          //  console.log("NONONONODE")
          network.body.data.nodes.update(data);
        }
        if (id == "edges"){
          //    console.log("EDGEEDGEDGE")
          data.forEach(function(e){
            //  console.log(e);
            network.body.data.edges.update(e);
          });
        }
        if (id == "nodes"){
          //    console.log("EDGEEDGEDGE")
          data.forEach(function(n){
            //  console.log(e);
            let type = n.type;

            var ntype = network.body.data.nodes.get({
              filter: function(node){
                //    console.log(node);
                return (node.label == n.type );
              }
            });
            if (ntype.length == 0){
              ntype[0] = network.body.data.nodes.add({label: n.type });
            }
            //  let ntypeId = network.body.data.nodes.update(n);
            let nodeId = network.body.data.nodes.update(n);
            let nZ = nodeId[0];
            let tZ = ntype[0][0] || ntype[0].id;
            console.log(nZ);
            console.log(tZ);

            let e = {from: nZ, to: tZ, label: 'type'};
            console.log(e)
            network.body.data.edges.update(e);
          });
        }
      });
      network.fit();
      network.redraw();
    }

    populateVis(db) {
      console.log("POPULATE");
      let network = this.network;
      network.body.data.nodes.clear();
      network.body.data.edges.clear();
      if (db.length > 0) {
        if (db.length % 100 < 5) {
          /*
          Rezoom tous les 100*/
          network.fit();
          network.redraw();
        }
        var nodes = [];
        var edges = [];
        var reste = [];
        db.forEach(function(t){
          if(t.predicate == "type" && t.object == "node"){
            nodes.push(t.subject);
            network.body.data.nodes.add({id: t.subject, type: t.object, y:2*Math.random()});
          }else if(t.predicate == "type" && t.object == "edge"){
            edges.push(t.subject);
          }  else{ reste.push(t);  }
        });
        reste.forEach(function(r){
          if (nodes.includes(r.subject)){
            var n = {id : r.subject}
            n[r.predicate] = r.object;
            network.body.data.nodes.update(n);
          }else if(edges.includes(r.subject)){
            var e = {id : r.subject}
            e[r.predicate] = r.object;
            network.body.data.edges.update(e);
          }else{
            console.log("Probleme non pris en compte : ")
            console.log(r)
          }
        });

        console.log(network)

        /*
        for (var i = 0; i < 10; i++) {
        var triplet = db.pop();
        if (triplet != undefined) {
        console.log(triplet);
        if (triplet.predicate == "type"  && triplet.object == "node") {
        console.log("NODE : "+triplet.subject);
        var noeudExist = network.body.data.nodes.get(triplet.subject);
        console.log(noeudExist)
        if (noeudExist == null || noeudExist.length == 0) {
        if (triplet.object.length > 40) {
        network.body.data.nodes.add({
        id: triplet.subject,
        label: triplet.object.match(/.{1,40}/g).join("\n"),
        //  shape: "box",
        group: 0
      });
    } else {
    var node = {
    id: triplet.subject,
    label: triplet.object,
    type: triplet.type,
    group: 0,
  };
  network.body.data.nodes.add(node);
  if ((node.label.toLowerCase() == "depart") || (node.label.toLowerCase() == "départ")) {
  //  console.log('trouve depart');
  //var nodeDep = network.body.data.nodes.get(triplet.subject);
  //console.log(nodeDep);
  //nodeDep.color = {background:'pink', border:'purple'};
  network.body.data.nodes.update({
  id: triplet.subject,
  color: {
  background: 'pink',
  border: 'purple'
}
})
var nodeDep = network.body.data.nodes.get(triplet.subject);
//nodeDep = network.body.data.nodes.get(triplet.subject);
network.focus(nodeDep.id);
network.fit();
}

}
} else {

network.body.data.nodes.update({
id: triplet.subject,
label: triplet.object,
type: triplet.type,
})
}
} else if (triplet.type == "shape") {
console.log(triplet);
network.body.data.nodes.update({
id: triplet.subject,
shape: triplet.object
})
}
else if (triplet.type == "color") {
console.log(triplet);
network.body.data.nodes.update({
id: triplet.subject,
color: triplet.object
})
}       else {
var edgeExist = [];
edgeExist = network.body.data.edges.get(triplet.subject);
if (edgeExist == null || edgeExist.length == 0) {
var edge = {
id: "",
from: "",
to: "",
label: "",
arrows: "to"
};
edge.id = triplet.subject;
edge[triplet.predicate] = triplet.object;
network.body.data.edges.add(edge);
} else {
var edge = edgeExist;
edge[triplet.predicate] = triplet.object;
network.body.data.edges.update(edge);
}
}
} else {
console.log("import terminé")
//  network.focus(nodeDep);
clearInterval(this.tickInterval);
var app = this;
console.log("revoir app.eyedata = app.network.body.data")

}
}*/
}
}





deleteFromServer (data){
  console.log("delete ")
  console.log(data)
  //Pour suppression, on recupere le noeud et ses liens envoyés par le serveur
  this.network.body.data.nodes.remove(data.nodes);
  this.network.body.data.edges.remove(data.edges);
}

describeFromDBpedia(results, resource){
  let app = this;
  console.log(results)
  let res = resource.split("#");
  //  console.log(conceptCut);
  let labelRes = res[res.length-1];
  if (labelRes == resource){
    res = resource.split("/");
    //console.log(conceptCut);
    labelRes = res[res.length-1];
  }
  results.forEach(function(r){
    console.log(r);
    let s,o;
    let p = r.p.value;
    if (r.s == undefined){
      s = labelRes;
    }else{
      s  = r.s.value;
    }
    if (r.o == undefined){
      o = labelRes;
    }else{
      o = r.o.value;
    }
    console.log(s +" "+p+" "+o)

    //recherche de noeuds existants
    var sujetNode = app.network.body.data.nodes.get({
      filter: function(node){return (node.label == s );}})[0];
      var objetNode = app.network.body.data.nodes.get({
        filter: function(node){return (node.label == o);}})[0];

        // sinon, on les créé
        if (sujetNode == undefined){
          let sArray = s.split("#");
          //  console.log(conceptCut);
          let labelS = sArray[sArray.length-1];
          if (labelS == s){
            sArray = s.split("/");
            //console.log(conceptCut);
            labelS = sArray[sArray.length-1];
          }
          sujetNode =  app.network.body.data.nodes.add({label: labelS, title: s, type: "node", y:2*Math.random() });
        }
        if (objetNode == undefined){
          let labelO = o;
          let shape = "ellipse";

          if (r.o.type == 'uri'){
            let oArray = o.split("#");
            //  console.log(conceptCut);
            labelO = oArray[oArray.length-1];
            if (labelO == o){
              oArray = o.split("/");
              //console.log(conceptCut);
              labelO = oArray[oArray.length-1];
            }
          }else{
            //literal
            shape ="box"
            if (o.length > 40) {
              labelO =  o.substring(0,40),
              o = o.match(/.{1,40}/g).join("\n")

            }
          }
          objetNode = app.network.body.data.nodes.add({label: labelO, title: o, type: "node", shape:shape, y:2*Math.random() });
        }
        console.log(sujetNode);
        console.log(objetNode);
        let pArray = p.split("#");
        //  console.log(conceptCut);
        let labelP = pArray[pArray.length-1];
        if (labelP == p){
          pArray = p.split("/");
          //console.log(conceptCut);
          labelP = pArray[pArray.length-1];
        }
        let edge = {
          title: p,
          label: labelP,
          from : sujetNode[0] || sujetNode.id,
          to : objetNode[0] || sujetNode.id,
          type: "edge",
        }
        console.log(edge)
        app.network.body.data.edges.add(edge);


      });
    }


    updateNetworkOptions(settings){
      console.log(settings)
      if(settings.centralGravity!= undefined){
        this.network.physics.options.repulsion.centralGravity = settings.centralGravity;
      }
      if(settings.springLength!= undefined){
        this.network.physics.options.repulsion.springLength = settings.springLength;
      }
      if(settings.springConstant!= undefined){
        this.network.physics.options.repulsion.springConstant = settings.springConstant;
      }
      if(settings.nodeDistance!= undefined){
        this.network.physics.options.repulsion.nodeDistance = settings.nodeDistance;
      }
      if(settings.damping!= undefined){
        this.network.physics.options.repulsion.damping = settings.damping;
      }
      console.log(this.network.physics.options.repulsion)
    }

    resetNetworkOptions(){
      this.network.physics.options.repulsion.centralGravity = this.centralGravityValueDefault;
      this.network.physics.options.repulsion.springLength = this.springLengthValueDefault;
      this.network.physics.options.repulsion.springConstant = this.springConstantValueDefault;
      this.network.physics.options.repulsion.nodeDistance = this.nodeDistanceValueDefault;
      this.network.physics.options.repulsion.damping = this.dampingValueDefault;
      console.log(this.network.physics.options.repulsion)
    }



    catchTriplet(message){
      // A REVOIR ET REMPLACER PAR catchTripletsV2() ??
      //  console.log(message.length);
      //message=message.trim();
      //  var tripletString = message.substring(2).trim().split(" ");
      //  var tripletString = message.trim().split(" ");
      // les noeuds existent-ils ?
      var sujetNode = this.network.body.data.nodes.get({
        filter: function(node){
          //    console.log(node);
          return (node.label == message[0] );
        }
      });
      if (sujetNode.length == 0){
        this.network.body.data.nodes.add({label: message[0], type: "node", x:10*Math.random(), y:10*Math.random() });
      }
      var objetNode = this.network.body.data.nodes.get({
        filter: function(node){
          //    console.log(node);
          return (node.label == message[2]);
        }
      });
      //  console.log(sujetNode);
      //  console.log(objetNode);
      // sinon, on les créé

      if (objetNode.length == 0){
        this.network.body.data.nodes.add({ label: message[2], type: "node", x:10*Math.random(), y:10*Math.random() });
      }
      // maintenant ils doivent exister, pas très po=ropre comme méthode , à revoir
      sujetNode = this.network.body.data.nodes.get({
        filter: function(node){
          return (node.label == message[0] );
        }
      });
      objetNode = this.network.body.data.nodes.get({
        filter: function(node){
          return (node.label == message[2]);
        }
      });
      var actionSujet = {};
      actionSujet.type = "newNode";
      actionSujet.data = sujetNode[0];
      //  actionsToSendTemp.push(actionSujet);
      //    this.addAction(actionSujet);

      var actionObjet = {};
      actionObjet.type = "newNode";
      actionObjet.data = objetNode[0];
      //  actionsToSendTemp.push(actionObjet);
      //  this.addAction(actionObjet);


      // maintenant, on peut ajouter l'edge
      this.network.body.data.edges.add({
        label: message[1],
        from : sujetNode[0].id,
        to : objetNode[0].id,
        type: "edge",
      });

      //on récupère ce edge pour l'envoyer au serveur
      var edge = this.network.body.data.edges.get({
        filter: function(edge) {
          return (edge.from == sujetNode[0].id && edge.to == objetNode[0].id && edge.label == message[1]);
        }
      });
      var actionEdge = {};
      actionEdge.type = "newEdge";
      actionEdge.data = edge;
      //  this.addAction(actionEdge);
      let actionstosend = [];
      actionstosend.push(actionSujet);
      actionstosend.push(actionObjet);
      actionstosend.push(actionEdge);
      this.agentGraph.send('agentSocket', {type: "newActions", actions: actionstosend});
      this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: actionstosend});


      //  actionsToSendTemp.push(actionEdge);
      //console.log(actionsToSendTemp);
      //  return actionsToSendTemp;
    }

    exportJson() {
      var network = this.network;
      console.log(network)
      var filename = prompt("Sous quel nom sauvegarder ce graphe ?", "Spoggy");
      //  app.$.inputMessage.value = '';
      if (filename == null || filename == "") {
        txt = "User cancelled the prompt.";
        return;
      }
      var textToWrite = "";
      var fileNameToSaveAs = filename+"_spoggy_nodes_edges_" + Date.now() + ".json";
      var textFileAsBlob = "";

      console.log("export Json");
      console.log(network.body.data);
      var nodes_edges = { nodes: network.body.data.nodes.get(), edges: network.body.data.edges.get() };
      console.log(nodes_edges);
      var nodes_edgesJSON = JSON.stringify(nodes_edges);
      console.log(nodes_edgesJSON);
      textFileAsBlob = new Blob([nodes_edgesJSON], {
        type:
        'application/json'
      }
    );
    var downloadLink = document.createElement("a");
    downloadLink.download = fileNameToSaveAs;
    downloadLink.innerHTML = "Download File";
    if(navigator.userAgent.indexOf("Chrome") != -1)
    {
      // Chrome allows the link to be clicked
      // without actually adding it to the DOM.
      console.log("CHROME");
      downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
    } else
    {
      // Firefox requires the link to be added to the DOM
      // before it can be clicked.
      console.log("FF");
      downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
      downloadLink.target="_blank";
      //downloadLink.onclick = destroyClickedElement;
      //downloadLink.onclick = window.URL.revokeObjectURL(downloadLink);
      downloadLink.style.display = "none";
      document.body.appendChild(downloadLink);
      //  console.log(app.$.popupTtl);
    }
    console.log(downloadLink);
    /*downloadLink.click();*/
    /* creation d'un event car download.click() ne fonctionne pas sous Firefox */
    var event = document.createEvent("MouseEvents");
    event.initMouseEvent(
      "click", true, false, window, 0, 0, 0, 0, 0
      , false, false, false, false, 0, null
    );
    downloadLink.dispatchEvent(event);
    var app = this;
    setTimeout(function(){
      console.log(downloadLink.parentNode);
      document.body.removeChild(downloadLink);
      window.URL.revokeObjectURL(downloadLink);
    }, 1000);
    /*if (window.URL != null) {
    // Chrome allows the link to be clicked
    // without actually adding it to the DOM.
    downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
  } else {
  // Firefox requires the link to be added to the DOM
  // before it can be clicked.
  downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
  downloadLink.onclick = destroyClickedElement;
  downloadLink.style.display = "none";
  document.body.appendChild(downloadLink);
}
downloadLink.click();*/
}



exportTtl() {
  /* source https://github.com/scenaristeur/dreamcatcherAutonome/blob/master/autonome/public/agents/ExportAgent.js */
  let network = this.network;
  var nodes = network.body.data.nodes.get();
  var edges = network.body.data.edges.get();
  console.log("exportation");
  console.log(nodes);
  console.log(edges);
  //creation des statements (triplets)
  /*var statements = [];
  for (var j = 0; j < edges.length; j++){
  var edge = edges[j];
  console.log(edge);
  statements.push({sujet: node.id, propriete: "rdfs:label", objet: node.label});
}
console.log(statements);*/

var output = "@prefix : <http://smag0.blogspot.fr/spoggy#> . \n";
output += "@prefix owl: <http://www.w3.org/2002/07/owl#> . \n";
output += "@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . \n";
output += "@prefix xml: <http://www.w3.org/XML/1998/namespace> . \n";
output += "@prefix xsd: <http://www.w3.org/2001/XMLSchema#> . \n";
output += "@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . \n";
output += "@prefix smag: <http://smag0.blogspot.fr/spoggy#> . \n";
output += "@base <http://smag0.blogspot.fr/spoggy> . \n";
output += "<http://smag0.blogspot.fr/spoggy> rdf:type owl:Ontology ;  \n";
output += "                    owl:versionIRI <http://smag0.blogspot.fr/spoggy/1.0.0> . \n";
output += " \n";
output += "owl:Class rdfs:subClassOf owl:Thing .  \n";

var listeInfos = new Array();
var listeComplementaire = new Array();

for (var i = 0; i < edges.length; i++) {
  var edge = edges[i];

  var sujet = edge.from;
  var propriete = edge.label;
  var objet = edge.to;


  //string.indexOf(substring) > -1
  //console.log(sujet);
  //console.log(propriete);
  //  console.log(objet);

  // AJOUTER EVENTUELLEMENT LA RECUPERATION DE SHAPE, COLOR, pour l'export RDF
  var sujetLabel = network.body.data.nodes.get(sujet).label;
  var objetLabel = network.body.data.nodes.get(objet).label;
  //console.log("#########################");
  //console.log(sujetLabel);
  //console.log(objetLabel)
  //console.log("#########################");

  var sujetWithPrefix = this.validRdf(network, sujet);
  var proprieteWithPrefix = this.validRdf(network, propriete);
  var objetWithPrefix = this.validRdf(network, objet);

  if (sujetWithPrefix.indexOf(':') == -1) { // ne contient pas de ':'
  sujetWithPrefix = ':' + sujetWithPrefix;
}

if (proprieteWithPrefix.indexOf(':') == -1) { // ne contient pas de ':'
proprieteWithPrefix = ':' + proprieteWithPrefix;

}

if (objetWithPrefix.indexOf(':') == -1) { // ne contient pas de ':'
objetWithPrefix = ':' + objetWithPrefix;
}


var typedeProp = ["owl:AnnotationProperty", "owl:ObjectProperty", "owl:DatatypeProperty"];
var indiceTypeDeProp = 1; // -1 pour ne pas ajouter la prop, sinon par defaut en annotationProperty, 1 pour Object, 2 pour Datatype --> revoir pour les datatypes

if ((proprieteWithPrefix == "type") || (proprieteWithPrefix == ":type") || (proprieteWithPrefix == "rdf:type")) {
  proprieteWithPrefix = "rdf:type";
  listeComplementaire.push(objetWithPrefix + " rdf:type owl:Class . \n");
  indiceTypeDeProp = 1;


} else if ((proprieteWithPrefix == "subClassOf") || (proprieteWithPrefix == ":subClassOf") || (proprieteWithPrefix == "rdfs:subClassOf")) {
  proprieteWithPrefix = "rdfs:subClassOf";

}
else if ((proprieteWithPrefix == "sameAs") || (proprieteWithPrefix == ":sameAs")) {
  proprieteWithPrefix = "owl:sameAs";
  indiceTypeDeProp = -1;
}
else if ((proprieteWithPrefix.toLowerCase() == "ispartof") || (proprieteWithPrefix.toLowerCase() == "partof") || (proprieteWithPrefix.toLowerCase() == ":ispartof") || (proprieteWithPrefix.toLowerCase() == ":partof") || (proprieteWithPrefix.toLowerCase() == ":ispartof")) {
  proprieteWithPrefix = "smag:partOf";
  indiceTypeDeProp = 1;

} else if ((proprieteWithPrefix.toLowerCase() == "comment") || (proprieteWithPrefix.toLowerCase() == "commentaire") || (proprieteWithPrefix.toLowerCase() == "//") || (proprieteWithPrefix.toLowerCase() == "#")) {
  proprieteWithPrefix = "rdfs:comment";
  indiceTypeDeProp = -1;

}


if (indiceTypeDeProp >= 0) {
  listeComplementaire.push(proprieteWithPrefix + " rdf:type " + typedeProp[indiceTypeDeProp] + " . \n");
}
var data = sujetWithPrefix + " " + proprieteWithPrefix + " " + objetWithPrefix + " . \n";
data += sujetWithPrefix + " " + "rdfs:label \"" + sujetLabel + "\" . \n";
data += objetWithPrefix + " " + "rdfs:label \"" + objetLabel + "\" . \n";
listeInfos[i] = data;
console.log(data);
console.log("||||||||||||||||||||||--");
}
//console.log(listeInfos);
//console.log(listeComplementaire);
//suppression des doublons
listeInfos = this.uniq_fast(listeInfos.sort());
listeComplementaire = this.uniq_fast(listeComplementaire.sort());
// console.log (listeInfos);
for (var k = 0; k < listeInfos.length; k++) {
  output = output + listeInfos[k];
  //  console.log(output);
}

for (var l = 0; l < listeComplementaire.length; l++) {
  output = output + listeComplementaire[l];
  //  console.log(output);
}


this.$.dialogs.$.inputTextToSave.value = output; //     document.getElementById("inputTextToSave").value =output;
/*this.$.dialogs.$.popupTtl.fitInto = this.$.dialogs.$.menu;*/
this.$.dialogs.$.popupTtl.toggle();
}

uniq_fast(a) {
  var seen = {};
  var out = [];
  var len = a.length;
  var j = 0;
  for(var i = 0; i < len; i++) {
    var item = a[i];
    if(seen[item] !== 1) {
      seen[item] = 1;
      out[j++] = item;
    }
  }
  return out;
}

newGraph(){
  //network.body.data.nodes.clear();
  //network.body.data.edges.clear();
  let network = this.network;

  var graphname = prompt("Comment nommer ce nouveau graphe ?", "Spoggy-Graph_"+Date.now());
  var nodeName = {
    label: graphname,
    shape: "star",
    color: "green",
    type: "node"
  };
  var nodeGraph = {
    label: "Graph",
    /*    shape: "star",
    color: "red",*/
    type: "node"
  };
  network.body.data.nodes.clear();
  network.body.data.edges.clear();
  var nodes = network.body.data.nodes.add([nodeName, nodeGraph]);

  var edge = {
    from: nodes[0],
    to: nodes[1],
    arrows: "to",
    label: "type"
  }
  network.body.data.edges.add(edge);
  /* seulement en cas de synchro, mais difficile de newgrapher en synchro ?
  var action = {};
  action.type = "newNode";
  action.data = nodeName;
  this.addAction(action);

  action = {};
  action.type = "newNode";
  action.data = nodeGraph;
  this.addAction(action);

  action = {};
  action.type = "newEdge";
  action.data = edge;
  this.addAction(action);

  action = {};
  action.type = "changeGraph";
  action.data = graphname;
  this.addAction(action);
  if(app.socket != undefined){
  app.socket.graph = graphname;
  console.log(app.socket);
}
*/

//app.socket.emit('newGraph', graphname);
/*
//document.getElementById('importPopUp').style.display = 'block';
app.$.importPopUp.style.display = 'block';

var filepicker = app.$.filepicker;
filepicker.addEventListener('change', handleFileSelect.bind(app), false);
filepicker.network = network;*/
}

validRdf(network, string){
  // A REVOIR
  console.log(network.body.data.nodes.get(string));
  console.log("nettoyage "+ string);
  // transformer le noeud en noeud rdf (resource ou literal)
  // ajouter la construction du noeud, son uri, prefix, localname, type...
  var valid = {};
  valid.type = "uri";
  if (string.indexOf(" ") !== -1){
    valid.type = "literal";
  }else{
    /*
    replaceAll(string, " ","_");
    replaceAll(string, "","_");
    replaceAll(string, ",","_");
    replaceAll(string, ";","_");
    replaceAll(string, " ","_");*/
  }

  return string;
}


decortiqueFile(fichier, remplaceNetwork){
  //  var network = network;
  //  console.log(network);
  let network = this.network;
  //  console.log(fichier);
  var reader = new FileReader(); //https://openclassrooms.com/courses/dynamisez-vos-sites-web-avec-javascript/l-api-file
  reader.addEventListener('load', function () {
    //  console.log(fichier);
    /*loadstart : La lecture vient de commencer.
    progress : Tout comme avec les objets XHR, l'événement progress se déclenche à intervalles réguliers durant la progression de la lecture. Il fournit, lui aussi, un objet en paramètre possédant deux propriétés, loaded et total, indiquant respectivement le nombre d'octets lus et le nombre d'octets à lire en tout.
    load : La lecture vient de se terminer avec succès.
    loadend : La lecture vient de se terminer (avec ou sans succès).
    abort : Se déclenche quand la lecture est interrompue (avec la méthode abort() par exemple).
    error : Se déclenche quand une erreur a été rencontrée. La propriété error contiendra alors un objet de type FileError pouvant vous fournir plus d'informations.*/
    //    console.log(this.result);
    //alert('Contenu du fichier "' + fichier.name + '" :\n\n' + reader.result);


    switch (fichier.type) {
      case "":
      case "text/plain":
      case "application/json":
      //    console.log("JSON");
      //  thisElement.dispatch('addNodesEdgesJSON', JSON.parse(reader.result));
      //    console.log(network);
      var nodes = JSON.parse(reader.result).nodes;
      //    console.log(nodes);
      var edges = JSON.parse(reader.result).edges;
      //    console.log(edges);
      network.beforeImport = [];
      network.beforeImport.nodes = network.body.data.nodes.get();
      network.beforeImport.edges = network.body.data.edges.get();
      network.body.data.nodes.update(nodes);
      network.body.data.edges.update(edges);
      if(remplaceNetwork){
        console.log(remplaceNetwork);
        network.body.data.nodes.clear();
        network.body.data.edges.clear();
        console.log("clear");
        network.body.data.nodes.add(nodes); // clear() ne semble pas fonctionner, à revoir
        network.body.data.edges.add(edges);
        console.log(network);
      }else{

        try{
          network.body.data.nodes.update(nodes);
          network.body.data.edges.update(edges);
        }
        catch(e){
          console.log(e);
        }
      }
      console.log(network);
      //  console.log(partageImport);
      break;
      case "rdf+xml":
      case "application/rdf+xml":
      console.log("fichier RDF"); //https://github.com/scenaristeur/dreamcatcherAutonome/blob/8376cb5211095a90314e34e9d286b820fbed335b/autonome1/public/agents/FichierAgent.js
      rdf2Xml(reader.result, network);
      //  network.dispatch('addTriplets', network.triplets);// CREER UNE NOUVELLE ACTION POUR ENVOYER TS LES TRIPLETS
      break;
      case "turtle":
      case "text/turtle":
      case "application/turtle":
      console.log("fichier turtle");
      console.log("ce type de fichier n'est pas pris en compte (" + fichier.type + ")");
      ttl2Xml(reader.result, network);
      //network.dispatch('addTriplets', network.triplets);
      break;
      default:
      console.log("ce type de fichier n'est pas pris en compte (" + fichier.type + ")");
      var extension = fichier.name.split('.').pop();
      console.log(extension);
      console.log(fichier);
      //  console.log(reader.result);
      if ((extension == "ttl") || (extension == "n3") || (extension == "n3t")) {
        //   sketch.ttl2Xml(reader.result);
        ttl2Xml(reader.result, network);
        //  network.dispatch('addTriplets', network.triplets);
      } else if ((extension == "rdf") || (extension == "owl")) {
        //  sketch.data2Xml(reader.result); //if srdf
        rdf2Xml(reader.result, network);
        //  network.dispatch('addTriplets', network.triplets);
      }
      else if ((extension == "json") || (reader.result.startsWith("[{"))) {
        // json2Xml(reader.result);
        //  network.dispatch('addNodesEdgesJSON', JSON.parse(reader.result));
      } else {
        data2Xml(reader.result, network);
      }
      console.log("fichier lu");
    }

    // thisApp.dispatch('update_triplets2add', this.triplets2add);

  });
  console.log(fichier);

  reader.readAsText(fichier);
}




shapeIsImage(shape){
  console.log(shape)
  return shape != "image" && shape != "circularImage";
}


//////////////////////////////////////////////////////////////////
networkDivInitialize(container, app){
  console.log(app.centralGravityValueDefault)
  // create an array with nodes
  var nodes = new vis.DataSet([
    {id: "node1", label: 'Spoggy', color: 'rgb(195,238,0)'},
    {id: "node2", label: 'Application Web', color: 'rgba(97,238,195)'},
    {id: "node3", label: 'David'},
    /*  {id: "node4", label: 'Bob'},*/
    {id: "node5", label: 'Graph', color: 'rgba(195,238,97)', cid:2},
    {id: "node6", label: 'Spoggy est une application permettant la création de graphes.', color: 'rgba(238,97,195)', shape: 'box', cid:1},
    /*    {id: "node7", label: 'Description', color: 'rgba(238,97,195,0.5)', cid:1},*/
    {id: "node8", label: 'Un graphe est un ensemble de noeuds\n et de liens entre ces noeuds.', color: 'rgba(238,97,195)', shape: 'box', cid:1},
    /*  {id: "node9", label: 'graph0', color: 'rgba(238,97,195,0.5)', type: 'graph', name: 'graph0'},
    {id: "node10", label: 'graph1', color: 'rgba(238,97,195,0.5)', type: 'graph', name: 'graph1'},
    {id: "node11", label: 'graph2', color: 'rgba(238,97,195,0.5)', type: 'graph', name: 'graph2'},
    {id: "node12", label: 'Input', color: 'rgba(195,238,97,0.5)', cid:2},*/
  ]);
  // create an array with edges
  var edges = new vis.DataSet([
    {from: "node1", to: "node2", label: "type", array:"to"},
    {from: "node1", to: "node3", label: "developpeur", array:"to"},
    //  {from: "node3", to: "node4", label: "connait", array:"to"},
    {from: "node1", to: "node5", label: "utilise", array:"to"},
    //  {from: "node1", to: "node12", label: "hasPart", array:"to"},
    {from: "node1", to: "node6", label: "description", array:"to"},
    //   {from: "node6", to: "node7", label: "type", array:"to"},
    {from: "node5", to: "node8", label: "description", array:"to"},
    /*  {from: "node8", to: "node7", label: "type", array:"to"},
    /    {from: "node9", to: "node5", label: "type", array:"to"},
    {from: "node10", to: "node5", label: "type", array:"to"},
    {from: "node11", to: "node5", label: "type", array:"to"},
    {from: "node1", to: "node9", label: "first", array:"to"},*/

  ]);
  /*var data = {
  nodes: nodes,
  edges: edges
};*/
//  var data = this.init;
var data = {};
var options = {
  locale: 'fr',
  /*configure: {
  enabled: true,
  filter: 'nodes,edges',
  container: settings,
  showButton: true
},*/
edges:{
  arrows: {
    to:     {enabled: true, scaleFactor:1, type:'arrow'},
    middle: {enabled: false, scaleFactor:1, type:'arrow'},
    from:   {enabled: false, scaleFactor:1, type:'arrow'}
  }},
  interaction:{
    navigationButtons: true,
    //  keyboard: true  //incompatible avec rappel de commande en cours d'implémentation
    multiselect: true,
  },

  manipulation: {
    addNode: function (data, callback) {
      // filling in the popup DOM elements
      data.label = "";
      //  console.log(this);
      app.editNode(data, callback);
    },
    editNode: function (data, callback) {
      // filling in the popup DOM elements
      //document.getElementById('nodeOperation').innerHTML = "Edit Node";
      data.edit = true; // signalement d'une edition pour sparql
      console.log(data);
      app.$.nodeOperation.innerHTML = "Edit Node";
      app.editNode(data, callback);
    },
    deleteNode: function (data, callback) {
      // filling in the popup DOM elements
      app.deleteNode(data, callback);
    },
    addEdge: function (data, callback) {
      if (data.from == data.to) {
        var r = confirm("Êtes-vous certain de vouloir connecter le noeud à lui-même?");
        if (r != true) {
          callback(null);
          return;
        }
      }
      //document.getElementById('edgeOperation').innerHTML = "Add Edge";
      app.$.edgeOperation.innerHTML = "Add Edge";
      app.editEdgeWithoutDrag(data, callback);
    },
    editEdge: {
      editWithoutDrag: function(data, callback) {
        //document.getElementById('edgeOperation').innerHTML = "Edit Edge";
        data.edit = true; // signalement d'une edition pour sparql
        console.log(data);
        app.$.edgeOperation.innerHTML = "Edit Edge";
        app.editEdgeWithoutDrag(data,callback);
      }
    },
    deleteEdge: function(data,callback){
      app.deleteEdge(data,callback);
    }
  },
  physics:{
    enabled: true,
    barnesHut: {
      gravitationalConstant: -1,
      centralGravity: 0.3,
      springLength: 95,
      springConstant: 0.04,
      damping: 0.09,
      avoidOverlap: 1
    },
    forceAtlas2Based: {
      gravitationalConstant: -50,
      centralGravity: 0.01,
      springConstant: 0.08,
      springLength: 100,
      damping: 0.4,
      avoidOverlap: 0
    },
    repulsion: {
      centralGravity: app.centralGravityValueDefault,  //0.001, //0.001 ? A quoi sert cette valeur ?
      springLength: app.springLengthValueDefault,   // 220, //220 (//200 //300)
      springConstant: app.springConstantValueDefault, //0.01, //0.01
      nodeDistance:  app.nodeDistanceValueDefault, //150, //100 //350
      damping: app.dampingValueDefault, ///0.08
    },
    hierarchicalRepulsion: {
      centralGravity: 0.0,
      springLength: 100,
      springConstant: 0.01,
      nodeDistance: 120,
      damping: 0.09
    },
    maxVelocity: 500, //50
    minVelocity: 1, //0.1
    solver: 'repulsion',
    stabilization: {
      enabled: true,
      iterations: 1000,
      updateInterval: 100,
      onlyDynamicEdges: false,
      fit: true
    },
    timestep: 0.5,
    adaptiveTimestep: true
  }
};
console.log(options)
return new vis.Network(container, data, options);
}
editNode (data, callback) {
  console.log(data);
  this.$.nodeLabel.value= data.label || "";
  this.selectedShape = data.shape || "ellipse";
  this.selectedType = data.type || "node";
  this.imageUrl = data.image || "";
  if ((data.color != undefined) && (data.color.background != undefined)){
    this.colorValue = data.color.background
  }
  else{
    this.colorValue =   "rgb(173,208,255)";
  }
  this.$.nodeSaveButton.onclick = this.saveNodeData.bind(this, data, callback);
  this.$.nodeCancelButton.onclick = this.clearNodePopUp.bind(this);

  this.$.nodePopUp.toggle(); //style.display = 'block';
}




clearNodePopUp () {
  this.$.nodeSaveButton.onclick = null;
  this.$.nodeCancelButton.onclick = null;
  //  this.$.nodePopUp.toggle();//style.display = 'none';
}
cancelNodeEdit (callback) {
  this.clearNodePopUp(this);
  callback(null);
}
saveNodeData (data, callback) {
  /*
  let dataTemp = data;
  let cb = callback;
  console.log(dataTemp);
  console.log(cb);
  console.log(data.type);
  data et callback apparaissent comme des events ?????
  {id: "38e05a49-feb0-4d65-a35f-c7c7d973390e", x: -518.5339336634761, y: -388.3170534287593, label: ""}
  spoggy-graph.html:373 Event {isTrusted: false, detail: {…}, type: "tap", target: paper-button#nodeSaveButton, currentTarget: paper-button#nodeSaveButton, …}
  spoggy-graph.html:374 {x: 138, y: 588, sourceEvent: MouseEvent, preventer: undefined}preventer: undefinedsourceEvent: MouseEvent {isTrusted: true, __polymerGesturesHandled: {…}, screenX: 2058, screenY: 654, clientX: 138, …}x: 138y: 588__proto__: Object
  spoggy-graph.html:378 tap
  */

  data.label = this.$.nodeLabel.value;
  data.shape = this.selectedShape;
  data.color = this.colorValue;
  data.image = this.$.imgUrl.value;

  data.type = this.selectedType;
  if (data.label.length > 40){
    var titleTemp =data.label.match(/.{1,40}/g);
    //  console.log(titleTemp);
    data.title = titleTemp.join("<br>");
    data.label = titleTemp[0]+'...';
    data.shape = "box";
    //  data.mass = 1/data.label.length
  }
  this.clearNodePopUp(this);
  callback(data);
  var node = this.network.body.data.nodes.get(data.id);
  console.log(node);
  var action = {};
  action.type = "newNode";
  action.data = node;
  console.log
  this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
  this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
  if( data.type == "graph"){
    console.log("nodeID");
    console.log(node.id);
    var graphNode = this.network.body.data.nodes.get({
      filter: function(node){
        console.log(node);
        return (node.label == "Graph" );
      }
    });
    console.log(graphNode);
    if (graphNode.length == 0){
      console.log("creation du noeud graph");
      var nodeGraph = {};
      nodeGraph.label = "Graph";
      nodeGraph.shape = "star";
      nodeGraph.type = "node";
      nodeGraph.color= "rgb(255,0,0)";
      this.network.body.data.nodes.add(nodeGraph);
    }else{
      console.log("récupération du noeud graph");
    }
    graphNode = this.network.body.data.nodes.get({
      filter: function(node){
        console.log(node);
        return (node.label == "Graph" );
      }
    });
    var actionNodeGraph = {};
    actionNodeGraph.type = "newNode";
    actionNodeGraph.data = graphNode[0];
    //  this.addAction(actionNodeGraph);
    this.agentGraph.send('agentSocket', {type: "newActions", actions: [actionNodeGraph]});
    this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [actionNodeGraph]});
    console.log(graphNode);
    console.log(node.id);
    var edgeGraph = {};
    edgeGraph.from = node.id;
    edgeGraph.to = graphNode[0].id;
    edgeGraph.label = "type";
    var graphEdge = this.network.body.data.edges.get({
      filter: function(edge){
        console.log(edge);
        return (edge.from == edgeGraph.from && edge.to == edgeGraph.to && edge.label == edgeGraph.label);
      }
    });
    console.log(graphEdge);
    if(graphEdge.length == 0){
      this.network.body.data.edges.add(edgeGraph);
    }
    graphEdge = this.network.body.data.edges.get({
      filter: function(edge){
        console.log(edge);
        return (edge.from == edgeGraph.from && edge.to == edgeGraph.to && edge.label == edgeGraph.label);
      }
    });
    console.log("EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEee");
    console.log(graphEdge);
    var actionedgeGraph = {};
    actionedgeGraph.type = "newEdge";
    actionedgeGraph.data = graphEdge;
    //    this.addAction(actionedgeGraph);
    this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
    this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
  }
  /*
  if( data.type == "graph"){
  var graphNode = this.network.body.data.nodes.get({
  filter: function(node){
  console.log(node);
  return (node.label == "Graph" );
}
});
console.log(graphNode);
var n ;
if(graphNode.length==0){
console.log("creation");
// creation du noeud Graph
var nodeGraph = {};
nodeGraph.label = "Graph";
nodeGraph.shape = "star";
n= this.network.body.data.nodes.add(nodeGraph)[0];
}else{
console.log("exist");
n = graphNode[0].id;
}
console.log(n);
var actionTo = {};
actionTo.type = "newNode";
actionTo.data = this.network.body.data.nodes.get(n);
console.log(actionTo);
this.addAction(actionTo);
var edgeGraph = {};
edgeGraph.label = "type";
edgeGraph.from = data.id;
edgeGraph.to = n;
this.addEdgeIfNotExist(this.network, edgeGraph);
var edge;
var existEdge = this.network.body.data.edges.get({
filter: function(edge){
return (edge.from == edgeGraph.from && edge.to == edgeGraph.to && edge.label == edgeGraph.label);
}
});
console.log(existEdge);
if(existEdge.length == 0){
edge = this.network.body.data.edges.update(edgeGraph);
}else{
edge = existEdge[0];
}
console.log(edge);
var actionGraph = {};
actionGraph.type = "newEdge";
//var e= this.network.body.data.edges.update(edgeGraph);
var e = this.network.body.data.edges.get(edge[0]);
console.log(e);
actionGraph.data = e;
console.log(actionGraph);
this.addAction(actionGraph);
*/
//}
/*this.nodes = [];
this.nodes = this.network.body.data.nodes;*/
}



editEdgeWithoutDrag (data, callback) {
  this.$.edgeLabel.value = data.label || "";
  this.$.edgeSaveButton.onclick = this.saveEdgeData.bind(this, data, callback);
  this.$.edgeLabel.onchange = this.saveEdgeData.bind(this, data, callback);
  this.$.edgeCancelButton.onclick = this.cancelEdgeEdit.bind(this,callback);
  this.$.edgePopUp.toggle(); //style.display = 'block';
}
clearEdgePopUp () {
  this.$.edgeSaveButton.onclick = null;
  this.$.edgeCancelButton.onclick = null;
  //  this.$.edgePopUp.toggle(); //style.display = 'none';
}
cancelEdgeEdit (callback) {
  this.clearEdgePopUp();
  callback(null);
}
saveEdgeData (data, callback) {
  if (typeof data.to === 'object')
  data.to = data.to.id
  if (typeof data.from === 'object')
  data.from = data.from.id
  data.label = this.$.edgeLabel.value;
  this.clearEdgePopUp();
  callback(data);
  var edge = this.network.body.data.edges.get({
    filter: function(edge) {
      return (edge.from == data.from && edge.to == data.to && edge.label == data.label);
    }
  });
  var action = {};
  action.type = "newEdge";
  action.data = edge;
  //  this.addAction(action);
  this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
  this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
}
deleteNode (data, callback){
  var action = {};
  action.type = "deleteNode";
  action.data = data;
  //  this.addAction(action);
  this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
  this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
  callback(data);
}
deleteEdge (data, callback){
  var action = {};
  action.type = "deleteEdge";
  action.data = data;
  //  this.addAction(action);
  this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
  this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
  callback(data);
}

addEdgeIfNotExist (network, data){
  var existEdge = false;
  console.log(data);
  try {
    existEdge = this.network.body.data.edges.get({
      filter: function(edge){
        return (edge.id == data[0].id);
      }
    });
    if (existEdge.length == 0){
      this.network.body.data.edges.add(data[0]);
    }else{
      this.network.body.data.edges.update({id: data[0].id, label: data[0].label});
    }
  }
  catch (err) {
    console.log(err);
  }
}
addNodeIfNotExist(network, data){
  var existNode = false;
  console.log(data);
  try{
    existNode = this.network.body.data.nodes.get({
      filter: function(node){
        return (node.id == data.id || (node.label == data.label && node.title == node.label));
      }
    });
    console.log(existNode);
    if (existNode.length == 0){
      console.log("n'existe pas")
      this.network.body.data.nodes.add(data);
    }else{
      console.log("existe")
      delete data.x;
      delete data.y
      this.network.body.data.nodes.update(data);
    }
  }
  catch (err){
    console.log(err);
  }
}




_inferedChanged(newInfered,oldinfered){
  console.log("INFERED");
  console.log(newInfered);
  this.populateFromInfered(newInfered, this.network)
}


populateFromInfered(infered, network){
  if(network != undefined){
    console.log(infered);
    if(infered.length != 0){
      infered.forEach(function(triplet){
        //var triplet = infered.pop();
        console.log(triplet);
        if (triplet != undefined) {
          console.log(infered.length);
          var sujet = triplet[0].trim();
          var propriete = triplet[1].trim();
          var objet = triplet[2].trim();
          var sujetExist = network.body.data.nodes.get({
            filter: function(node){
              //    console.log(node);
              return (node.label == sujet );
            }
          });
          var objetExist = network.body.data.nodes.get({
            filter: function(node){
              //    console.log(node);
              return (node.label == objet );
            }
          });
          if(sujetExist == null  || sujetExist.length == 0){
            console.log("creation "+sujet);
            var node = {
              label: sujet,
              group: 100, // règles
              borderWidth: 2,
              shape: "diamond",
              color: "rgb(255,153,30)"
            };
            network.body.data.nodes.add(node);
          }else{
            console.log(sujet+ " exist");
            console.log(sujetExist);
            //  network.body.data.nodes.update({id: sujetExist[0].id, group: 1,borderWidth: 2,shape: "diamond"});
          }
          if(objetExist == null  || objetExist.length == 0){
            console.log("creation "+objet);
            var node = {
              label: objet,
              group: 100,
              borderWidth: 2,
              shape: "diamond",
              color: "rgb(255,153,30)"
            };
            network.body.data.nodes.add(node);
          }else{
            console.log(objet+ " exist");
            console.log(objetExist);
            //  network.body.data.nodes.update({id: sujetExist[0].id, group: 1,borderWidth: 2,shape: "diamond"});
          }
          sujetExist = network.body.data.nodes.get({
            filter: function(node){
              //    console.log(node);
              return (node.label == sujet );
            }
          });
          objetExist = network.body.data.nodes.get({
            filter: function(node){
              //    console.log(node);
              return (node.label == objet );
            }
          });
          var edgeExist = network.body.data.edges.get({
            filter: function(edge) {
              return (edge.from == sujetExist[0].id && edge.to == objetExist[0].id && edge.label == propriete);
            }
          });
          if (edgeExist == null || edgeExist.length == 0) {
            var edge = {
              from: sujetExist[0].id,
              to: objetExist[0].id,
              label: propriete,
              group: 100, // règles
              arrows: "to",
              color: "rgb(255,153,30)"
            };
            //edge.id = triplet.subject;
            //edge[triplet.predicate] = triplet.object;
            console.log("add");
            console.log(edge);
            network.body.data.edges.add(edge);
          } else {
            console.log("update");
            console.log(edgeExist);
            //var edge = edgeExist;
            //edge[triplet.predicate] = triplet.object;
            //  network.body.data.edges.update(edge);
          }
        }
      });
    }
    else{
      console.log("suppression des inférences");
      var edgesInferres = network.body.data.edges.get({
        filter: function(edge){
          //    console.log(node);
          return (edge.group == 100 );
        }
      });
      console.log(edgesInferres);
      network.body.data.edges.remove(edgesInferres);
      var nodesInferres = network.body.data.nodes.get({
        filter: function(node){
          //    console.log(node);
          return (node.group == 100 );
        }
      });
      console.log(nodesInferres);
      network.body.data.nodes.remove(nodesInferres);
    }
  }
}
// CLUSTERS
_toggleDesc() {
  //  network.setData(data);
  var clusterOptionsByData = {
    joinCondition:function(childOptions) {
      return childOptions.cid == 1;
    },
    processProperties: function (clusterOptions, childNodes) {
      //clusterIndex = clusterIndex + 1;
      var clusterIndex = 1
      var childrenCount = 0;
      for (var i = 0; i < childNodes.length; i++) {
        childrenCount += childNodes[i].childrenCount || 1;
      }
      clusterOptions.childrenCount = childrenCount;
      clusterOptions.label = "Description\n# " + childrenCount + "";
      // clusterOptions.font = {size: childrenCount*5+30}
      clusterOptions.id = 'cluster:' + clusterIndex;
      clusterOptions.mass = 1/childrenCount;
      // clusters.push({id:'cluster:' + clusterIndex, scale:scale});
      return clusterOptions;
    },
    clusterNodeProperties: {id:'cidCluster',  color: 'rgba(97,238,195,0.5)', borderWidth:3, shape:'box'}
  };
  this.network.cluster(clusterOptionsByData);
}
_closeImportPopUp(){
  this.$.importPopUp.toggle(); //.style.display = 'none';
}
/*_toogle() {
console.log("clic");
this.$.nodePopUp.toggle();
}*/
saveTextAsFile(){
  var textToWrite="";
  var fileNameToSaveAs="";
  var textFileAsBlob="";
  var extension="ttl";
  var nomFichier="";
  var data = this.$.inputTextToSave.value;
  console.log(data);
  if((typeof data != "undefined")&& (data.length>0)){
    textToWrite=data;
  }else{
    textToWrite = this.$.inputTextToSave.value;    //textToWrite = document.getElementById("inputTextToSave").value;
  }
  if ((typeof nomFichier != "undefined") && (nomFichier.length>0)){
    fileNameToSaveAs = nomFichier+"."+extension;
  }else{
    fileNameToSaveAs = this.$.inputFileNameToSaveAs.value+"."+extension; // fileNameToSaveAs = document.getElementById("inputFileNameToSaveAs").value+"."+extension;
  }
  if ((typeof extension != "undefined") && (extension.length>0)){
    switch(extension){
      case "ttl" :
      textFileAsBlob = new Blob([textToWrite], {
        type:
        'text/turtle'
      }
    );
    break;
    case "rdf" :
    //pas implementé pour l'instant
    textFileAsBlob = new Blob([textToWrite], {
      type:
      'application/rdf+xml'
    }
  );
  break;
  default :
  console.log("non traite  , extension : "+extension);
  break;
}
}
console.log(nomFichier+" : "+extension);
var downloadLink = document.createElement("a");
downloadLink.download = fileNameToSaveAs;
downloadLink.innerHTML = "Download File";
//console.log(window.URL);
//if (window.URL != null)
if(navigator.userAgent.indexOf("Chrome") != -1)
{
  // Chrome allows the link to be clicked
  // without actually adding it to the DOM.
  console.log("CHROME");
  downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
} else
{
  // Firefox requires the link to be added to the DOM
  // before it can be clicked.
  console.log("FF");
  downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
  downloadLink.target="_blank";
  //downloadLink.onclick = destroyClickedElement;
  //downloadLink.onclick = window.URL.revokeObjectURL(downloadLink);
  downloadLink.style.display = "none";
  document.body.appendChild(downloadLink);
  console.log(this.$.popupTtl);
}
console.log(downloadLink);
/*downloadLink.click();*/
/* creation d'un event car download.click() ne fonctionne pas sous Firefox */
var event = document.createEvent("MouseEvents");
event.initMouseEvent(
  "click", true, false, window, 0, 0, 0, 0, 0
  , false, false, false, false, 0, null
);
downloadLink.dispatchEvent(event);
var app = this;
setTimeout(function(){
  document.body.removeChild(downloadLink);
  window.URL.revokeObjectURL(downloadLink);
}, 100);
console.log(this.$.popupTtl);
this.$.popupTtl.toggle();
}



recupParams(){
  var params = (function(a) {
    if (a == "") return {};
    var b = {};
    for (var i = 0; i < a.length; ++i)
    {        var p=a[i].split('=', 2);
    if (p.length == 1)
    b[p[0]] = "";
    else
    b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
  }
  return b;
})(window.location.search.substr(1).split('&'));
return params;
}

}
});
</script>
